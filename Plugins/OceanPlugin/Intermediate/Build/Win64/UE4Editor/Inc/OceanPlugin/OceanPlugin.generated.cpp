// Copyright 1998-2016 Epic Games, Inc. All Rights Reserved.
/*===========================================================================
	Boilerplate C++ definitions for a single module.
	This is automatically generated by UnrealHeaderTool.
	DO NOT modify this manually! Edit the corresponding .h files instead!
===========================================================================*/

#include "Classes/OceanPluginPrivatePCH.h"
#include "GeneratedCppIncludes.h"
#include "OceanPlugin.generated.dep.h"
PRAGMA_DISABLE_DEPRECATION_WARNINGS
void EmptyLinkFunctionForGeneratedCode1OceanPlugin() {}
class UScriptStruct* FWaveSetParameters::StaticStruct()
{
	extern OCEANPLUGIN_API class UPackage* Z_Construct_UPackage__Script_OceanPlugin();
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern OCEANPLUGIN_API class UScriptStruct* Z_Construct_UScriptStruct_FWaveSetParameters();
		extern OCEANPLUGIN_API uint32 Get_Z_Construct_UScriptStruct_FWaveSetParameters_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FWaveSetParameters, Z_Construct_UPackage__Script_OceanPlugin(), TEXT("WaveSetParameters"), sizeof(FWaveSetParameters), Get_Z_Construct_UScriptStruct_FWaveSetParameters_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FWaveSetParameters(FWaveSetParameters::StaticStruct, TEXT("/Script/OceanPlugin"), TEXT("WaveSetParameters"), false, nullptr, nullptr);
static struct FScriptStruct_OceanPlugin_StaticRegisterNativesFWaveSetParameters
{
	FScriptStruct_OceanPlugin_StaticRegisterNativesFWaveSetParameters()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("WaveSetParameters")),new UScriptStruct::TCppStructOps<FWaveSetParameters>);
	}
} ScriptStruct_OceanPlugin_StaticRegisterNativesFWaveSetParameters;
class UScriptStruct* FWaveParameter::StaticStruct()
{
	extern OCEANPLUGIN_API class UPackage* Z_Construct_UPackage__Script_OceanPlugin();
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern OCEANPLUGIN_API class UScriptStruct* Z_Construct_UScriptStruct_FWaveParameter();
		extern OCEANPLUGIN_API uint32 Get_Z_Construct_UScriptStruct_FWaveParameter_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FWaveParameter, Z_Construct_UPackage__Script_OceanPlugin(), TEXT("WaveParameter"), sizeof(FWaveParameter), Get_Z_Construct_UScriptStruct_FWaveParameter_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FWaveParameter(FWaveParameter::StaticStruct, TEXT("/Script/OceanPlugin"), TEXT("WaveParameter"), false, nullptr, nullptr);
static struct FScriptStruct_OceanPlugin_StaticRegisterNativesFWaveParameter
{
	FScriptStruct_OceanPlugin_StaticRegisterNativesFWaveParameter()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("WaveParameter")),new UScriptStruct::TCppStructOps<FWaveParameter>);
	}
} ScriptStruct_OceanPlugin_StaticRegisterNativesFWaveParameter;
	void AOceanManager::StaticRegisterNativesAOceanManager()
	{
		FNativeFunctionRegistrar::RegisterFunction(AOceanManager::StaticClass(), "GetHeightmapPixel",(Native)&AOceanManager::execGetHeightmapPixel);
		FNativeFunctionRegistrar::RegisterFunction(AOceanManager::StaticClass(), "GetWaveHeightValue",(Native)&AOceanManager::execGetWaveHeightValue);
		FNativeFunctionRegistrar::RegisterFunction(AOceanManager::StaticClass(), "LoadLandscapeHeightmap",(Native)&AOceanManager::execLoadLandscapeHeightmap);
	}
	IMPLEMENT_CLASS(AOceanManager, 2818809385);
	void UBuoyancyComponent::StaticRegisterNativesUBuoyancyComponent()
	{
	}
	IMPLEMENT_CLASS(UBuoyancyComponent, 2300455205);
class UScriptStruct* FStructBoneOverride::StaticStruct()
{
	extern OCEANPLUGIN_API class UPackage* Z_Construct_UPackage__Script_OceanPlugin();
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern OCEANPLUGIN_API class UScriptStruct* Z_Construct_UScriptStruct_FStructBoneOverride();
		extern OCEANPLUGIN_API uint32 Get_Z_Construct_UScriptStruct_FStructBoneOverride_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FStructBoneOverride, Z_Construct_UPackage__Script_OceanPlugin(), TEXT("StructBoneOverride"), sizeof(FStructBoneOverride), Get_Z_Construct_UScriptStruct_FStructBoneOverride_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FStructBoneOverride(FStructBoneOverride::StaticStruct, TEXT("/Script/OceanPlugin"), TEXT("StructBoneOverride"), false, nullptr, nullptr);
static struct FScriptStruct_OceanPlugin_StaticRegisterNativesFStructBoneOverride
{
	FScriptStruct_OceanPlugin_StaticRegisterNativesFStructBoneOverride()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("StructBoneOverride")),new UScriptStruct::TCppStructOps<FStructBoneOverride>);
	}
} ScriptStruct_OceanPlugin_StaticRegisterNativesFStructBoneOverride;
	void UBuoyancyForceComponent::StaticRegisterNativesUBuoyancyForceComponent()
	{
	}
	IMPLEMENT_CLASS(UBuoyancyForceComponent, 3099503236);
	void UBuoyantDestructibleComponent::StaticRegisterNativesUBuoyantDestructibleComponent()
	{
	}
	IMPLEMENT_CLASS(UBuoyantDestructibleComponent, 3995881944);
	void ABuoyantDestructible::StaticRegisterNativesABuoyantDestructible()
	{
	}
	IMPLEMENT_CLASS(ABuoyantDestructible, 2954976017);
	void UBuoyantMeshComponent::StaticRegisterNativesUBuoyantMeshComponent()
	{
	}
	IMPLEMENT_CLASS(UBuoyantMeshComponent, 3562595155);
	void ACustomVehicleController::StaticRegisterNativesACustomVehicleController()
	{
		FNativeFunctionRegistrar::RegisterFunction(ACustomVehicleController::StaticClass(), "DrawBuoyancyPoints",(Native)&ACustomVehicleController::execDrawBuoyancyPoints);
		FNativeFunctionRegistrar::RegisterFunction(ACustomVehicleController::StaticClass(), "EnableBuoyancy",(Native)&ACustomVehicleController::execEnableBuoyancy);
		FNativeFunctionRegistrar::RegisterFunction(ACustomVehicleController::StaticClass(), "EnterVehicle",(Native)&ACustomVehicleController::execEnterVehicle);
		FNativeFunctionRegistrar::RegisterFunction(ACustomVehicleController::StaticClass(), "ExitVehicle",(Native)&ACustomVehicleController::execExitVehicle);
		FNativeFunctionRegistrar::RegisterFunction(ACustomVehicleController::StaticClass(), "GetIsDriving",(Native)&ACustomVehicleController::execGetIsDriving);
	}
	IMPLEMENT_CLASS(ACustomVehicleController, 4063001813);
	void AFishManager::StaticRegisterNativesAFishManager()
	{
	}
	IMPLEMENT_CLASS(AFishManager, 2225279414);
	void AFlockFish::StaticRegisterNativesAFlockFish()
	{
		FNativeFunctionRegistrar::RegisterFunction(AFlockFish::StaticClass(), "OnBeginOverlap",(Native)&AFlockFish::execOnBeginOverlap);
		FNativeFunctionRegistrar::RegisterFunction(AFlockFish::StaticClass(), "OnEndOverlap",(Native)&AFlockFish::execOnEndOverlap);
	}
	IMPLEMENT_CLASS(AFlockFish, 1264340217);
static class UEnum* EFollowMethod_StaticEnum()
{
	extern OCEANPLUGIN_API class UPackage* Z_Construct_UPackage__Script_OceanPlugin();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern OCEANPLUGIN_API class UEnum* Z_Construct_UEnum_OceanPlugin_EFollowMethod();
		Singleton = GetStaticEnum(Z_Construct_UEnum_OceanPlugin_EFollowMethod, Z_Construct_UPackage__Script_OceanPlugin(), TEXT("EFollowMethod"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_EFollowMethod(EFollowMethod_StaticEnum, TEXT("/Script/OceanPlugin"), TEXT("EFollowMethod"), false, nullptr, nullptr);
	void UInfiniteSystemComponent::StaticRegisterNativesUInfiniteSystemComponent()
	{
	}
	IMPLEMENT_CLASS(UInfiniteSystemComponent, 3439605165);
class UScriptStruct* FTimeDate::StaticStruct()
{
	extern OCEANPLUGIN_API class UPackage* Z_Construct_UPackage__Script_OceanPlugin();
	static class UScriptStruct* Singleton = NULL;
	if (!Singleton)
	{
		extern OCEANPLUGIN_API class UScriptStruct* Z_Construct_UScriptStruct_FTimeDate();
		extern OCEANPLUGIN_API uint32 Get_Z_Construct_UScriptStruct_FTimeDate_CRC();
		Singleton = GetStaticStruct(Z_Construct_UScriptStruct_FTimeDate, Z_Construct_UPackage__Script_OceanPlugin(), TEXT("TimeDate"), sizeof(FTimeDate), Get_Z_Construct_UScriptStruct_FTimeDate_CRC());
	}
	return Singleton;
}
static FCompiledInDeferStruct Z_CompiledInDeferStruct_UScriptStruct_FTimeDate(FTimeDate::StaticStruct, TEXT("/Script/OceanPlugin"), TEXT("TimeDate"), false, nullptr, nullptr);
static struct FScriptStruct_OceanPlugin_StaticRegisterNativesFTimeDate
{
	FScriptStruct_OceanPlugin_StaticRegisterNativesFTimeDate()
	{
		UScriptStruct::DeferCppStructOps(FName(TEXT("TimeDate")),new UScriptStruct::TCppStructOps<FTimeDate>);
	}
} ScriptStruct_OceanPlugin_StaticRegisterNativesFTimeDate;
	void ATimeManager::StaticRegisterNativesATimeManager()
	{
		FNativeFunctionRegistrar::RegisterFunction(ATimeManager::StaticClass(), "CalculateMoonAngle",(Native)&ATimeManager::execCalculateMoonAngle);
		FNativeFunctionRegistrar::RegisterFunction(ATimeManager::StaticClass(), "CalculateMoonPhase",(Native)&ATimeManager::execCalculateMoonPhase);
		FNativeFunctionRegistrar::RegisterFunction(ATimeManager::StaticClass(), "CalculateSunAngle",(Native)&ATimeManager::execCalculateSunAngle);
		FNativeFunctionRegistrar::RegisterFunction(ATimeManager::StaticClass(), "GetDayOfYear",(Native)&ATimeManager::execGetDayOfYear);
		FNativeFunctionRegistrar::RegisterFunction(ATimeManager::StaticClass(), "GetDayPhase",(Native)&ATimeManager::execGetDayPhase);
		FNativeFunctionRegistrar::RegisterFunction(ATimeManager::StaticClass(), "GetDaysInMonth",(Native)&ATimeManager::execGetDaysInMonth);
		FNativeFunctionRegistrar::RegisterFunction(ATimeManager::StaticClass(), "GetDaysInYear",(Native)&ATimeManager::execGetDaysInYear);
		FNativeFunctionRegistrar::RegisterFunction(ATimeManager::StaticClass(), "GetElapsedDayInMinutes",(Native)&ATimeManager::execGetElapsedDayInMinutes);
		FNativeFunctionRegistrar::RegisterFunction(ATimeManager::StaticClass(), "GetYearPhase",(Native)&ATimeManager::execGetYearPhase);
		FNativeFunctionRegistrar::RegisterFunction(ATimeManager::StaticClass(), "IncrementTime",(Native)&ATimeManager::execIncrementTime);
		FNativeFunctionRegistrar::RegisterFunction(ATimeManager::StaticClass(), "InitializeCalendar",(Native)&ATimeManager::execInitializeCalendar);
		FNativeFunctionRegistrar::RegisterFunction(ATimeManager::StaticClass(), "IsLeapYear",(Native)&ATimeManager::execIsLeapYear);
		FNativeFunctionRegistrar::RegisterFunction(ATimeManager::StaticClass(), "SetCurrentLocalTime",(Native)&ATimeManager::execSetCurrentLocalTime);
	}
	IMPLEMENT_CLASS(ATimeManager, 2719956129);
	void UWaterHeightmapComponent::StaticRegisterNativesUWaterHeightmapComponent()
	{
	}
	IMPLEMENT_CLASS(UWaterHeightmapComponent, 2668524278);
#if USE_COMPILED_IN_NATIVES
// Cross Module References
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FLinearColor();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FVector();
	ENGINE_API class UClass* Z_Construct_UClass_UWorld_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UTexture2D_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_AActor();
	LANDSCAPE_API class UClass* Z_Construct_UClass_ALandscape_NoRegister();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FVector2D();
	ENGINE_API class UClass* Z_Construct_UClass_UMovementComponent();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FRotator();
	ENGINE_API class UClass* Z_Construct_UClass_USceneComponent();
	ENGINE_API class UEnum* Z_Construct_UEnum_Engine_ETickingGroup();
	ENGINE_API class UClass* Z_Construct_UClass_UDestructibleComponent();
	ENGINE_API class UClass* Z_Construct_UClass_UStaticMeshComponent();
	ENGINE_API class UClass* Z_Construct_UClass_APawn_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_APlayerController();
	COREUOBJECT_API class UClass* Z_Construct_UClass_UObject_NoRegister();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FHitResult();
	ENGINE_API class UClass* Z_Construct_UClass_UPrimitiveComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_AActor_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_APawn();
	ENGINE_API class UClass* Z_Construct_UClass_USphereComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UActorComponent();

	OCEANPLUGIN_API class UScriptStruct* Z_Construct_UScriptStruct_FWaveSetParameters();
	OCEANPLUGIN_API class UScriptStruct* Z_Construct_UScriptStruct_FWaveParameter();
	OCEANPLUGIN_API class UFunction* Z_Construct_UFunction_AOceanManager_GetHeightmapPixel();
	OCEANPLUGIN_API class UFunction* Z_Construct_UFunction_AOceanManager_GetWaveHeightValue();
	OCEANPLUGIN_API class UFunction* Z_Construct_UFunction_AOceanManager_LoadLandscapeHeightmap();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_AOceanManager_NoRegister();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_AOceanManager();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_UBuoyancyComponent_NoRegister();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_UBuoyancyComponent();
	OCEANPLUGIN_API class UScriptStruct* Z_Construct_UScriptStruct_FStructBoneOverride();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_UBuoyancyForceComponent_NoRegister();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_UBuoyancyForceComponent();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_UBuoyantDestructibleComponent_NoRegister();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_UBuoyantDestructibleComponent();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_ABuoyantDestructible_NoRegister();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_ABuoyantDestructible();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_UBuoyantMeshComponent_NoRegister();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_UBuoyantMeshComponent();
	OCEANPLUGIN_API class UFunction* Z_Construct_UFunction_ACustomVehicleController_DrawBuoyancyPoints();
	OCEANPLUGIN_API class UFunction* Z_Construct_UFunction_ACustomVehicleController_EnableBuoyancy();
	OCEANPLUGIN_API class UFunction* Z_Construct_UFunction_ACustomVehicleController_EnterVehicle();
	OCEANPLUGIN_API class UFunction* Z_Construct_UFunction_ACustomVehicleController_ExitVehicle();
	OCEANPLUGIN_API class UFunction* Z_Construct_UFunction_ACustomVehicleController_GetIsDriving();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_ACustomVehicleController_NoRegister();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_ACustomVehicleController();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_AFishManager_NoRegister();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_AFishManager();
	OCEANPLUGIN_API class UFunction* Z_Construct_UFunction_AFlockFish_OnBeginOverlap();
	OCEANPLUGIN_API class UFunction* Z_Construct_UFunction_AFlockFish_OnEndOverlap();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_AFlockFish_NoRegister();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_AFlockFish();
	OCEANPLUGIN_API class UEnum* Z_Construct_UEnum_OceanPlugin_EFollowMethod();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_UInfiniteSystemComponent_NoRegister();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_UInfiniteSystemComponent();
	OCEANPLUGIN_API class UScriptStruct* Z_Construct_UScriptStruct_FTimeDate();
	OCEANPLUGIN_API class UFunction* Z_Construct_UFunction_ATimeManager_CalculateMoonAngle();
	OCEANPLUGIN_API class UFunction* Z_Construct_UFunction_ATimeManager_CalculateMoonPhase();
	OCEANPLUGIN_API class UFunction* Z_Construct_UFunction_ATimeManager_CalculateSunAngle();
	OCEANPLUGIN_API class UFunction* Z_Construct_UFunction_ATimeManager_GetDayOfYear();
	OCEANPLUGIN_API class UFunction* Z_Construct_UFunction_ATimeManager_GetDayPhase();
	OCEANPLUGIN_API class UFunction* Z_Construct_UFunction_ATimeManager_GetDaysInMonth();
	OCEANPLUGIN_API class UFunction* Z_Construct_UFunction_ATimeManager_GetDaysInYear();
	OCEANPLUGIN_API class UFunction* Z_Construct_UFunction_ATimeManager_GetElapsedDayInMinutes();
	OCEANPLUGIN_API class UFunction* Z_Construct_UFunction_ATimeManager_GetYearPhase();
	OCEANPLUGIN_API class UFunction* Z_Construct_UFunction_ATimeManager_IncrementTime();
	OCEANPLUGIN_API class UFunction* Z_Construct_UFunction_ATimeManager_InitializeCalendar();
	OCEANPLUGIN_API class UFunction* Z_Construct_UFunction_ATimeManager_IsLeapYear();
	OCEANPLUGIN_API class UFunction* Z_Construct_UFunction_ATimeManager_SetCurrentLocalTime();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_ATimeManager_NoRegister();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_ATimeManager();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_UWaterHeightmapComponent_NoRegister();
	OCEANPLUGIN_API class UClass* Z_Construct_UClass_UWaterHeightmapComponent();
	OCEANPLUGIN_API class UPackage* Z_Construct_UPackage__Script_OceanPlugin();
	UScriptStruct* Z_Construct_UScriptStruct_FWaveSetParameters()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_OceanPlugin();
		extern uint32 Get_Z_Construct_UScriptStruct_FWaveSetParameters_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("WaveSetParameters"), sizeof(FWaveSetParameters), Get_Z_Construct_UScriptStruct_FWaveSetParameters_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("WaveSetParameters"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FWaveSetParameters>, EStructFlags(0x00000201));
			UProperty* NewProp_Wave08 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Wave08"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Wave08, FWaveSetParameters), 0x0010000000000005, Z_Construct_UScriptStruct_FWaveParameter());
			UProperty* NewProp_Wave07 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Wave07"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Wave07, FWaveSetParameters), 0x0010000000000005, Z_Construct_UScriptStruct_FWaveParameter());
			UProperty* NewProp_Wave06 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Wave06"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Wave06, FWaveSetParameters), 0x0010000000000005, Z_Construct_UScriptStruct_FWaveParameter());
			UProperty* NewProp_Wave05 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Wave05"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Wave05, FWaveSetParameters), 0x0010000000000005, Z_Construct_UScriptStruct_FWaveParameter());
			UProperty* NewProp_Wave04 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Wave04"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Wave04, FWaveSetParameters), 0x0010000000000005, Z_Construct_UScriptStruct_FWaveParameter());
			UProperty* NewProp_Wave03 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Wave03"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Wave03, FWaveSetParameters), 0x0010000000000005, Z_Construct_UScriptStruct_FWaveParameter());
			UProperty* NewProp_Wave02 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Wave02"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Wave02, FWaveSetParameters), 0x0010000000000005, Z_Construct_UScriptStruct_FWaveParameter());
			UProperty* NewProp_Wave01 = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Wave01"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Wave01, FWaveSetParameters), 0x0010000000000005, Z_Construct_UScriptStruct_FWaveParameter());
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("* Contains the parameters necessary for a set of Gerstner waves."));
			MetaData->SetValue(NewProp_Wave08, TEXT("Category"), TEXT("WaveSetParameters"));
			MetaData->SetValue(NewProp_Wave08, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
			MetaData->SetValue(NewProp_Wave07, TEXT("Category"), TEXT("WaveSetParameters"));
			MetaData->SetValue(NewProp_Wave07, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
			MetaData->SetValue(NewProp_Wave06, TEXT("Category"), TEXT("WaveSetParameters"));
			MetaData->SetValue(NewProp_Wave06, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
			MetaData->SetValue(NewProp_Wave05, TEXT("Category"), TEXT("WaveSetParameters"));
			MetaData->SetValue(NewProp_Wave05, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
			MetaData->SetValue(NewProp_Wave04, TEXT("Category"), TEXT("WaveSetParameters"));
			MetaData->SetValue(NewProp_Wave04, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
			MetaData->SetValue(NewProp_Wave03, TEXT("Category"), TEXT("WaveSetParameters"));
			MetaData->SetValue(NewProp_Wave03, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
			MetaData->SetValue(NewProp_Wave02, TEXT("Category"), TEXT("WaveSetParameters"));
			MetaData->SetValue(NewProp_Wave02, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
			MetaData->SetValue(NewProp_Wave01, TEXT("Category"), TEXT("WaveSetParameters"));
			MetaData->SetValue(NewProp_Wave01, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FWaveSetParameters_CRC() { return 2001542626U; }
	UScriptStruct* Z_Construct_UScriptStruct_FWaveParameter()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_OceanPlugin();
		extern uint32 Get_Z_Construct_UScriptStruct_FWaveParameter_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("WaveParameter"), sizeof(FWaveParameter), Get_Z_Construct_UScriptStruct_FWaveParameter_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("WaveParameter"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FWaveParameter>, EStructFlags(0x00000201));
			UProperty* NewProp_TimeScale = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("TimeScale"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(TimeScale, FWaveParameter), 0x0010000000000005);
			UProperty* NewProp_Steepness = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Steepness"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Steepness, FWaveParameter), 0x0010000000000005);
			UProperty* NewProp_Amplitude = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Amplitude"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Amplitude, FWaveParameter), 0x0010000000000005);
			UProperty* NewProp_Length = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Length"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Length, FWaveParameter), 0x0010000000000005);
			UProperty* NewProp_Rotation = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Rotation"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Rotation, FWaveParameter), 0x0010000000000005);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("* Contains the parameters necessary for a single Gerstner wave."));
			MetaData->SetValue(NewProp_TimeScale, TEXT("Category"), TEXT("WaveParameter"));
			MetaData->SetValue(NewProp_TimeScale, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
			MetaData->SetValue(NewProp_Steepness, TEXT("Category"), TEXT("WaveParameter"));
			MetaData->SetValue(NewProp_Steepness, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
			MetaData->SetValue(NewProp_Amplitude, TEXT("Category"), TEXT("WaveParameter"));
			MetaData->SetValue(NewProp_Amplitude, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
			MetaData->SetValue(NewProp_Length, TEXT("Category"), TEXT("WaveParameter"));
			MetaData->SetValue(NewProp_Length, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
			MetaData->SetValue(NewProp_Rotation, TEXT("Category"), TEXT("WaveParameter"));
			MetaData->SetValue(NewProp_Rotation, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FWaveParameter_CRC() { return 610456447U; }
	UFunction* Z_Construct_UFunction_AOceanManager_GetHeightmapPixel()
	{
		struct OceanManager_eventGetHeightmapPixel_Parms
		{
			float U;
			float V;
			FLinearColor ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AOceanManager();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetHeightmapPixel"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(OceanManager_eventGetHeightmapPixel_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, OceanManager_eventGetHeightmapPixel_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FLinearColor());
			UProperty* NewProp_V = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("V"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(V, OceanManager_eventGetHeightmapPixel_Parms), 0x0010000000000080);
			UProperty* NewProp_U = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("U"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(U, OceanManager_eventGetHeightmapPixel_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Ocean Manager"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AOceanManager_GetWaveHeightValue()
	{
		struct OceanManager_eventGetWaveHeightValue_Parms
		{
			FVector location;
			const UWorld* World;
			bool HeightOnly;
			bool TwoIterations;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_AOceanManager();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetWaveHeightValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04C20401, 65535, sizeof(OceanManager_eventGetWaveHeightValue_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, OceanManager_eventGetWaveHeightValue_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FVector());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(TwoIterations, OceanManager_eventGetWaveHeightValue_Parms, bool);
			UProperty* NewProp_TwoIterations = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TwoIterations"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(TwoIterations, OceanManager_eventGetWaveHeightValue_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(TwoIterations, OceanManager_eventGetWaveHeightValue_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(HeightOnly, OceanManager_eventGetWaveHeightValue_Parms, bool);
			UProperty* NewProp_HeightOnly = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HeightOnly"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(HeightOnly, OceanManager_eventGetWaveHeightValue_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(HeightOnly, OceanManager_eventGetWaveHeightValue_Parms), sizeof(bool), true);
			UProperty* NewProp_World = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("World"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(World, OceanManager_eventGetWaveHeightValue_Parms), 0x0010000000000082, Z_Construct_UClass_UWorld_NoRegister());
			UProperty* NewProp_location = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("location"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(location, OceanManager_eventGetWaveHeightValue_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Ocean Manager"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_HeightOnly"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_TwoIterations"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("HidePin"), TEXT("World"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
			MetaData->SetValue(NewProp_World, TEXT("NativeConst"), TEXT(""));
			MetaData->SetValue(NewProp_location, TEXT("NativeConst"), TEXT(""));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AOceanManager_LoadLandscapeHeightmap()
	{
		struct OceanManager_eventLoadLandscapeHeightmap_Parms
		{
			UTexture2D* Tex2D;
		};
		UObject* Outer=Z_Construct_UClass_AOceanManager();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LoadLandscapeHeightmap"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(OceanManager_eventLoadLandscapeHeightmap_Parms));
			UProperty* NewProp_Tex2D = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Tex2D"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Tex2D, OceanManager_eventLoadLandscapeHeightmap_Parms), 0x0010000000000080, Z_Construct_UClass_UTexture2D_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Ocean Manager"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_AOceanManager_NoRegister()
	{
		return AOceanManager::StaticClass();
	}
	UClass* Z_Construct_UClass_AOceanManager()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AActor();
			Z_Construct_UPackage__Script_OceanPlugin();
			OuterClass = AOceanManager::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900080;

				OuterClass->LinkChild(Z_Construct_UFunction_AOceanManager_GetHeightmapPixel());
				OuterClass->LinkChild(Z_Construct_UFunction_AOceanManager_GetWaveHeightValue());
				OuterClass->LinkChild(Z_Construct_UFunction_AOceanManager_LoadLandscapeHeightmap());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_HeightmapTexture = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("HeightmapTexture"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(HeightmapTexture, AOceanManager), 0x0010000000000005, Z_Construct_UClass_UTexture2D_NoRegister());
				UProperty* NewProp_Landscape = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Landscape"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Landscape, AOceanManager), 0x0010000000000005, Z_Construct_UClass_ALandscape_NoRegister());
				UProperty* NewProp_ModulationPower = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ModulationPower"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ModulationPower, AOceanManager), 0x0010000000000005);
				UProperty* NewProp_ModulationMaxHeight = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ModulationMaxHeight"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ModulationMaxHeight, AOceanManager), 0x0010000000000005);
				UProperty* NewProp_ModulationStartHeight = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ModulationStartHeight"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ModulationStartHeight, AOceanManager), 0x0010000000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bEnableLandscapeModulation, AOceanManager, bool);
				UProperty* NewProp_bEnableLandscapeModulation = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bEnableLandscapeModulation"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bEnableLandscapeModulation, AOceanManager), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bEnableLandscapeModulation, AOceanManager), sizeof(bool), true);
				UProperty* NewProp_NetWorkTimeOffset = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("NetWorkTimeOffset"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(NetWorkTimeOffset, AOceanManager), 0x0010000000000004);
				UProperty* NewProp_WaveSetOffsetsOverride = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("WaveSetOffsetsOverride"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(WaveSetOffsetsOverride, AOceanManager), 0x0010000000000005);
				UProperty* NewProp_WaveSetOffsetsOverride_Inner = new(EC_InternalUseOnlyConstructor, NewProp_WaveSetOffsetsOverride, TEXT("WaveSetOffsetsOverride"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FWaveSetParameters());
				UProperty* NewProp_WaveClusters = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("WaveClusters"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(WaveClusters, AOceanManager), 0x0010000000000005);
				UProperty* NewProp_WaveClusters_Inner = new(EC_InternalUseOnlyConstructor, NewProp_WaveClusters, TEXT("WaveClusters"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FWaveParameter());
				UProperty* NewProp_DistanceCheck = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DistanceCheck"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(DistanceCheck, AOceanManager), 0x0010000000000005);
				UProperty* NewProp_GlobalWaveAmplitude = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("GlobalWaveAmplitude"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(GlobalWaveAmplitude, AOceanManager), 0x0010000000000005);
				UProperty* NewProp_GlobalWaveSpeed = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("GlobalWaveSpeed"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(GlobalWaveSpeed, AOceanManager), 0x0010000000000005);
				UProperty* NewProp_GlobalWaveDirection = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("GlobalWaveDirection"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(GlobalWaveDirection, AOceanManager), 0x0010000000000005, Z_Construct_UScriptStruct_FVector2D());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(EnableGerstnerWaves, AOceanManager, bool);
				UProperty* NewProp_EnableGerstnerWaves = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("EnableGerstnerWaves"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(EnableGerstnerWaves, AOceanManager), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(EnableGerstnerWaves, AOceanManager), sizeof(bool), true);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AOceanManager_GetHeightmapPixel(), "GetHeightmapPixel"); // 160271789
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AOceanManager_GetWaveHeightValue(), "GetWaveHeightValue"); // 3433717028
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AOceanManager_LoadLandscapeHeightmap(), "LoadLandscapeHeightmap"); // 1843988515
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("OceanManager.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("OceanManager calculates the Gerstner waves in code, while the Material uses it's own implementation in a MaterialFunction.\nTODO: Investigate whether a single implementation could be used to increase performance."));
				MetaData->SetValue(NewProp_HeightmapTexture, TEXT("Category"), TEXT("OceanManager"));
				MetaData->SetValue(NewProp_HeightmapTexture, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
				MetaData->SetValue(NewProp_Landscape, TEXT("Category"), TEXT("OceanManager"));
				MetaData->SetValue(NewProp_Landscape, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
				MetaData->SetValue(NewProp_ModulationPower, TEXT("Category"), TEXT("OceanManager"));
				MetaData->SetValue(NewProp_ModulationPower, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
				MetaData->SetValue(NewProp_ModulationMaxHeight, TEXT("Category"), TEXT("OceanManager"));
				MetaData->SetValue(NewProp_ModulationMaxHeight, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
				MetaData->SetValue(NewProp_ModulationStartHeight, TEXT("Category"), TEXT("OceanManager"));
				MetaData->SetValue(NewProp_ModulationStartHeight, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
				MetaData->SetValue(NewProp_bEnableLandscapeModulation, TEXT("Category"), TEXT("OceanManager"));
				MetaData->SetValue(NewProp_bEnableLandscapeModulation, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
				MetaData->SetValue(NewProp_bEnableLandscapeModulation, TEXT("ToolTip"), TEXT("Landscape height modulation vars."));
				MetaData->SetValue(NewProp_NetWorkTimeOffset, TEXT("Category"), TEXT("OceanManager"));
				MetaData->SetValue(NewProp_NetWorkTimeOffset, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
				MetaData->SetValue(NewProp_WaveSetOffsetsOverride, TEXT("Category"), TEXT("OceanManager"));
				MetaData->SetValue(NewProp_WaveSetOffsetsOverride, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
				MetaData->SetValue(NewProp_WaveSetOffsetsOverride, TEXT("ToolTip"), TEXT("Individual Gerstner wave settings.\n      (leave blank to use the default offsets)."));
				MetaData->SetValue(NewProp_WaveClusters, TEXT("Category"), TEXT("OceanManager"));
				MetaData->SetValue(NewProp_WaveClusters, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
				MetaData->SetValue(NewProp_WaveClusters, TEXT("ToolTip"), TEXT("Median Gerstner wave settings\n      (only 1 cluster is used in the material by default)."));
				MetaData->SetValue(NewProp_DistanceCheck, TEXT("Category"), TEXT("OceanManager"));
				MetaData->SetValue(NewProp_DistanceCheck, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
				MetaData->SetValue(NewProp_DistanceCheck, TEXT("ToolTip"), TEXT("Optimization:\n      * If the distance of a buoyant point to base sea level exceeds DistanceCheck,\n      * skip the Gerstner calculations and return base sea level."));
				MetaData->SetValue(NewProp_GlobalWaveAmplitude, TEXT("Category"), TEXT("OceanManager"));
				MetaData->SetValue(NewProp_GlobalWaveAmplitude, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
				MetaData->SetValue(NewProp_GlobalWaveAmplitude, TEXT("ToolTip"), TEXT("The global amplitude multiplier of the waves."));
				MetaData->SetValue(NewProp_GlobalWaveSpeed, TEXT("Category"), TEXT("OceanManager"));
				MetaData->SetValue(NewProp_GlobalWaveSpeed, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
				MetaData->SetValue(NewProp_GlobalWaveSpeed, TEXT("ToolTip"), TEXT("The global speed multiplier of the waves."));
				MetaData->SetValue(NewProp_GlobalWaveDirection, TEXT("Category"), TEXT("OceanManager"));
				MetaData->SetValue(NewProp_GlobalWaveDirection, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
				MetaData->SetValue(NewProp_GlobalWaveDirection, TEXT("ToolTip"), TEXT("The global direction the waves travel."));
				MetaData->SetValue(NewProp_EnableGerstnerWaves, TEXT("Category"), TEXT("OceanManager"));
				MetaData->SetValue(NewProp_EnableGerstnerWaves, TEXT("ModuleRelativePath"), TEXT("Classes/OceanManager.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AOceanManager(Z_Construct_UClass_AOceanManager, &AOceanManager::StaticClass, TEXT("AOceanManager"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(AOceanManager);
	UClass* Z_Construct_UClass_UBuoyancyComponent_NoRegister()
	{
		return UBuoyancyComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UBuoyancyComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UMovementComponent();
			Z_Construct_UPackage__Script_OceanPlugin();
			OuterClass = UBuoyancyComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_WaveForceMultiplier = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("WaveForceMultiplier"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(WaveForceMultiplier, UBuoyancyComponent), 0x0010040000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(EnableWaveForces, UBuoyancyComponent, bool);
				UProperty* NewProp_EnableWaveForces = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("EnableWaveForces"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(EnableWaveForces, UBuoyancyComponent), 0x0010040000000005, CPP_BOOL_PROPERTY_BITMASK(EnableWaveForces, UBuoyancyComponent), sizeof(bool), true);
				UProperty* NewProp_StayUprightDesiredRotation = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("StayUprightDesiredRotation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(StayUprightDesiredRotation, UBuoyancyComponent), 0x0010040000000005, Z_Construct_UScriptStruct_FRotator());
				UProperty* NewProp_StayUprightDamping = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("StayUprightDamping"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(StayUprightDamping, UBuoyancyComponent), 0x0010040000000005);
				UProperty* NewProp_StayUprightStiffness = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("StayUprightStiffness"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(StayUprightStiffness, UBuoyancyComponent), 0x0010040000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(EnableStayUprightConstraint, UBuoyancyComponent, bool);
				UProperty* NewProp_EnableStayUprightConstraint = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("EnableStayUprightConstraint"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(EnableStayUprightConstraint, UBuoyancyComponent), 0x0010040000000005, CPP_BOOL_PROPERTY_BITMASK(EnableStayUprightConstraint, UBuoyancyComponent), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(DrawDebugPoints, UBuoyancyComponent, bool);
				UProperty* NewProp_DrawDebugPoints = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DrawDebugPoints"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(DrawDebugPoints, UBuoyancyComponent), 0x0010040000000005, CPP_BOOL_PROPERTY_BITMASK(DrawDebugPoints, UBuoyancyComponent), sizeof(bool), true);
				UProperty* NewProp_PointDensityOverride = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PointDensityOverride"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(PointDensityOverride, UBuoyancyComponent), 0x0010040000000005);
				UProperty* NewProp_PointDensityOverride_Inner = new(EC_InternalUseOnlyConstructor, NewProp_PointDensityOverride, TEXT("PointDensityOverride"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000);
				UProperty* NewProp_TestPoints = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TestPoints"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(TestPoints, UBuoyancyComponent), 0x0010000000000005);
				UProperty* NewProp_TestPoints_Inner = new(EC_InternalUseOnlyConstructor, NewProp_TestPoints, TEXT("TestPoints"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_TestPointRadius = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TestPointRadius"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(TestPointRadius, UBuoyancyComponent), 0x0010000000000005);
				UProperty* NewProp_MaxUnderwaterVelocity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxUnderwaterVelocity"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(MaxUnderwaterVelocity, UBuoyancyComponent), 0x0010000000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(ClampMaxVelocity, UBuoyancyComponent, bool);
				UProperty* NewProp_ClampMaxVelocity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ClampMaxVelocity"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ClampMaxVelocity, UBuoyancyComponent), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(ClampMaxVelocity, UBuoyancyComponent), sizeof(bool), true);
				UProperty* NewProp_VelocityDamper = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("VelocityDamper"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(VelocityDamper, UBuoyancyComponent), 0x0010040000000005, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_FluidAngularDamping = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FluidAngularDamping"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(FluidAngularDamping, UBuoyancyComponent), 0x0010000000000005);
				UProperty* NewProp_FluidLinearDamping = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FluidLinearDamping"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(FluidLinearDamping, UBuoyancyComponent), 0x0010000000000005);
				UProperty* NewProp_FluidDensity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FluidDensity"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(FluidDensity, UBuoyancyComponent), 0x0010000000000005);
				UProperty* NewProp_MeshDensity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MeshDensity"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(MeshDensity, UBuoyancyComponent), 0x0010000000000005);
				UProperty* NewProp_OceanManager = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OceanManager"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(OceanManager, UBuoyancyComponent), 0x0010040000000005, Z_Construct_UClass_AOceanManager_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Movement"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("PlanarMovement Components|Movement|Planar Velocity"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("BuoyancyComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyComponent.h"));
				MetaData->SetValue(NewProp_WaveForceMultiplier, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_WaveForceMultiplier, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyComponent.h"));
				MetaData->SetValue(NewProp_EnableWaveForces, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_EnableWaveForces, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyComponent.h"));
				MetaData->SetValue(NewProp_StayUprightDesiredRotation, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_StayUprightDesiredRotation, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyComponent.h"));
				MetaData->SetValue(NewProp_StayUprightDamping, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_StayUprightDamping, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyComponent.h"));
				MetaData->SetValue(NewProp_StayUprightStiffness, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_StayUprightStiffness, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyComponent.h"));
				MetaData->SetValue(NewProp_EnableStayUprightConstraint, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_EnableStayUprightConstraint, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyComponent.h"));
				MetaData->SetValue(NewProp_EnableStayUprightConstraint, TEXT("ToolTip"), TEXT("Stay upright physics constraint (inspired by UDK's StayUprightSpring)\n-STILL WIP-"));
				MetaData->SetValue(NewProp_DrawDebugPoints, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_DrawDebugPoints, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyComponent.h"));
				MetaData->SetValue(NewProp_PointDensityOverride, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_PointDensityOverride, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyComponent.h"));
				MetaData->SetValue(NewProp_PointDensityOverride, TEXT("ToolTip"), TEXT("Per-point mesh density override, can be used for half-sinking objects etc."));
				MetaData->SetValue(NewProp_TestPoints, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_TestPoints, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyComponent.h"));
				MetaData->SetValue(NewProp_TestPoints, TEXT("ToolTip"), TEXT("Test point array. At least one point is required for buoyancy"));
				MetaData->SetValue(NewProp_TestPointRadius, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_TestPointRadius, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyComponent.h"));
				MetaData->SetValue(NewProp_TestPointRadius, TEXT("ToolTip"), TEXT("Radius of the points"));
				MetaData->SetValue(NewProp_MaxUnderwaterVelocity, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_MaxUnderwaterVelocity, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyComponent.h"));
				MetaData->SetValue(NewProp_ClampMaxVelocity, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_ClampMaxVelocity, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyComponent.h"));
				MetaData->SetValue(NewProp_VelocityDamper, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_VelocityDamper, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyComponent.h"));
				MetaData->SetValue(NewProp_FluidAngularDamping, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_FluidAngularDamping, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyComponent.h"));
				MetaData->SetValue(NewProp_FluidAngularDamping, TEXT("ToolTip"), TEXT("Angular damping when object is in fluid"));
				MetaData->SetValue(NewProp_FluidLinearDamping, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_FluidLinearDamping, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyComponent.h"));
				MetaData->SetValue(NewProp_FluidLinearDamping, TEXT("ToolTip"), TEXT("Linear damping when object is in fluid"));
				MetaData->SetValue(NewProp_FluidDensity, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_FluidDensity, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyComponent.h"));
				MetaData->SetValue(NewProp_FluidDensity, TEXT("ToolTip"), TEXT("Density of water"));
				MetaData->SetValue(NewProp_MeshDensity, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_MeshDensity, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyComponent.h"));
				MetaData->SetValue(NewProp_MeshDensity, TEXT("ToolTip"), TEXT("Density of mesh"));
				MetaData->SetValue(NewProp_OceanManager, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_OceanManager, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyComponent.h"));
				MetaData->SetValue(NewProp_OceanManager, TEXT("ToolTip"), TEXT("OceanManager used by the component, if unassign component will auto-detect"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UBuoyancyComponent(Z_Construct_UClass_UBuoyancyComponent, &UBuoyancyComponent::StaticClass, TEXT("UBuoyancyComponent"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UBuoyancyComponent);
	UScriptStruct* Z_Construct_UScriptStruct_FStructBoneOverride()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_OceanPlugin();
		extern uint32 Get_Z_Construct_UScriptStruct_FStructBoneOverride_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("StructBoneOverride"), sizeof(FStructBoneOverride), Get_Z_Construct_UScriptStruct_FStructBoneOverride_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("StructBoneOverride"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FStructBoneOverride>, EStructFlags(0x00000201));
			UProperty* NewProp_TestRadius = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("TestRadius"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(TestRadius, FStructBoneOverride), 0x0010000000000005);
			UProperty* NewProp_Density = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Density"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Density, FStructBoneOverride), 0x0010000000000005);
			UProperty* NewProp_BoneName = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("BoneName"), RF_Public|RF_Transient|RF_MarkAsNative) UNameProperty(CPP_PROPERTY_BASE(BoneName, FStructBoneOverride), 0x0010000000000005);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
			MetaData->SetValue(ReturnStruct, TEXT("ToolTip"), TEXT("Custom bone density/radius override struct."));
			MetaData->SetValue(NewProp_TestRadius, TEXT("Category"), TEXT("Buoyancy"));
			MetaData->SetValue(NewProp_TestRadius, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
			MetaData->SetValue(NewProp_Density, TEXT("Category"), TEXT("Buoyancy"));
			MetaData->SetValue(NewProp_Density, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
			MetaData->SetValue(NewProp_BoneName, TEXT("Category"), TEXT("Buoyancy"));
			MetaData->SetValue(NewProp_BoneName, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FStructBoneOverride_CRC() { return 4073370848U; }
	UClass* Z_Construct_UClass_UBuoyancyForceComponent_NoRegister()
	{
		return UBuoyancyForceComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UBuoyancyForceComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_USceneComponent();
			Z_Construct_UPackage__Script_OceanPlugin();
			OuterClass = UBuoyancyForceComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20A80080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_TickGroup = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TickGroup"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(TickGroup, UBuoyancyForceComponent), 0x0010040000000005, Z_Construct_UEnum_Engine_ETickingGroup());
				UProperty* NewProp_WaveForceMultiplier = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("WaveForceMultiplier"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(WaveForceMultiplier, UBuoyancyForceComponent), 0x0010040000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(EnableWaveForces, UBuoyancyForceComponent, bool);
				UProperty* NewProp_EnableWaveForces = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("EnableWaveForces"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(EnableWaveForces, UBuoyancyForceComponent), 0x0010040000000005, CPP_BOOL_PROPERTY_BITMASK(EnableWaveForces, UBuoyancyForceComponent), sizeof(bool), true);
				UProperty* NewProp_StayUprightDesiredRotation = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("StayUprightDesiredRotation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(StayUprightDesiredRotation, UBuoyancyForceComponent), 0x0010040000000005, Z_Construct_UScriptStruct_FRotator());
				UProperty* NewProp_StayUprightDamping = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("StayUprightDamping"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(StayUprightDamping, UBuoyancyForceComponent), 0x0010040000000005);
				UProperty* NewProp_StayUprightStiffness = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("StayUprightStiffness"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(StayUprightStiffness, UBuoyancyForceComponent), 0x0010040000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(EnableStayUprightConstraint, UBuoyancyForceComponent, bool);
				UProperty* NewProp_EnableStayUprightConstraint = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("EnableStayUprightConstraint"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(EnableStayUprightConstraint, UBuoyancyForceComponent), 0x0010040000000005, CPP_BOOL_PROPERTY_BITMASK(EnableStayUprightConstraint, UBuoyancyForceComponent), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(DrawDebugPoints, UBuoyancyForceComponent, bool);
				UProperty* NewProp_DrawDebugPoints = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DrawDebugPoints"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(DrawDebugPoints, UBuoyancyForceComponent), 0x0010040000000005, CPP_BOOL_PROPERTY_BITMASK(DrawDebugPoints, UBuoyancyForceComponent), sizeof(bool), true);
				UProperty* NewProp_BoneOverride = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BoneOverride"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(BoneOverride, UBuoyancyForceComponent), 0x0010040000000005);
				UProperty* NewProp_BoneOverride_Inner = new(EC_InternalUseOnlyConstructor, NewProp_BoneOverride, TEXT("BoneOverride"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FStructBoneOverride());
				UProperty* NewProp_PointDensityOverride = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PointDensityOverride"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(PointDensityOverride, UBuoyancyForceComponent), 0x0010040000000005);
				UProperty* NewProp_PointDensityOverride_Inner = new(EC_InternalUseOnlyConstructor, NewProp_PointDensityOverride, TEXT("PointDensityOverride"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(TwoGerstnerIterations, UBuoyancyForceComponent, bool);
				UProperty* NewProp_TwoGerstnerIterations = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TwoGerstnerIterations"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(TwoGerstnerIterations, UBuoyancyForceComponent), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(TwoGerstnerIterations, UBuoyancyForceComponent), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(SnapToSurfaceIfNoPhysics, UBuoyancyForceComponent, bool);
				UProperty* NewProp_SnapToSurfaceIfNoPhysics = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SnapToSurfaceIfNoPhysics"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(SnapToSurfaceIfNoPhysics, UBuoyancyForceComponent), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(SnapToSurfaceIfNoPhysics, UBuoyancyForceComponent), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(ApplyForceToBones, UBuoyancyForceComponent, bool);
				UProperty* NewProp_ApplyForceToBones = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ApplyForceToBones"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ApplyForceToBones, UBuoyancyForceComponent), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(ApplyForceToBones, UBuoyancyForceComponent), sizeof(bool), true);
				UProperty* NewProp_TestPoints = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TestPoints"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(TestPoints, UBuoyancyForceComponent), 0x0010000000000005);
				UProperty* NewProp_TestPoints_Inner = new(EC_InternalUseOnlyConstructor, NewProp_TestPoints, TEXT("TestPoints"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_TestPointRadius = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TestPointRadius"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(TestPointRadius, UBuoyancyForceComponent), 0x0010000000000005);
				UProperty* NewProp_MaxUnderwaterVelocity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxUnderwaterVelocity"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(MaxUnderwaterVelocity, UBuoyancyForceComponent), 0x0010000000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(ClampMaxVelocity, UBuoyancyForceComponent, bool);
				UProperty* NewProp_ClampMaxVelocity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ClampMaxVelocity"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ClampMaxVelocity, UBuoyancyForceComponent), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(ClampMaxVelocity, UBuoyancyForceComponent), sizeof(bool), true);
				UProperty* NewProp_VelocityDamper = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("VelocityDamper"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(VelocityDamper, UBuoyancyForceComponent), 0x0010040000000005, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_FluidAngularDamping = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FluidAngularDamping"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(FluidAngularDamping, UBuoyancyForceComponent), 0x0010000000000005);
				UProperty* NewProp_FluidLinearDamping = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FluidLinearDamping"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(FluidLinearDamping, UBuoyancyForceComponent), 0x0010000000000005);
				UProperty* NewProp_FluidDensity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FluidDensity"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(FluidDensity, UBuoyancyForceComponent), 0x0010000000000005);
				UProperty* NewProp_MeshDensity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MeshDensity"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(MeshDensity, UBuoyancyForceComponent), 0x0010000000000005);
				UProperty* NewProp_OceanManager = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OceanManager"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(OceanManager, UBuoyancyForceComponent), 0x0010040000000005, Z_Construct_UClass_AOceanManager_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Physics"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Mobility LOD PhysicsVolume"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("BuoyancyForceComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Applies buoyancy forces to physics objects.\nOceanManager is required in the level for this to work."));
				MetaData->SetValue(NewProp_TickGroup, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_TickGroup, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_WaveForceMultiplier, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_WaveForceMultiplier, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_EnableWaveForces, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_EnableWaveForces, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_EnableWaveForces, TEXT("ToolTip"), TEXT("Waves will push objects towards the wave direction set in the Ocean Manager.\n-STILL WIP-"));
				MetaData->SetValue(NewProp_StayUprightDesiredRotation, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_StayUprightDesiredRotation, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_StayUprightDamping, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_StayUprightDamping, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_StayUprightStiffness, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_StayUprightStiffness, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_EnableStayUprightConstraint, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_EnableStayUprightConstraint, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_EnableStayUprightConstraint, TEXT("ToolTip"), TEXT("Stay upright physics constraint (inspired by UDK's StayUprightSpring)\n-STILL WIP-"));
				MetaData->SetValue(NewProp_DrawDebugPoints, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_DrawDebugPoints, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_BoneOverride, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_BoneOverride, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_BoneOverride, TEXT("ToolTip"), TEXT("Density & radius overrides per skeletal bone (ApplyForceToBones needs to be true)."));
				MetaData->SetValue(NewProp_PointDensityOverride, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_PointDensityOverride, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_PointDensityOverride, TEXT("ToolTip"), TEXT("Per-point mesh density override, can be used for half-sinking objects etc."));
				MetaData->SetValue(NewProp_TwoGerstnerIterations, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_TwoGerstnerIterations, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_TwoGerstnerIterations, TEXT("ToolTip"), TEXT("More accurate gerstner wave height calculations by accounting for the x/y displacement.\nKeep in mind that this effectively doubles the gerstner calculations per test point.\nUse only if accurate height readback is needed."));
				MetaData->SetValue(NewProp_SnapToSurfaceIfNoPhysics, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_SnapToSurfaceIfNoPhysics, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_SnapToSurfaceIfNoPhysics, TEXT("ToolTip"), TEXT("If object has no physics enabled, snap to water surface."));
				MetaData->SetValue(NewProp_ApplyForceToBones, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_ApplyForceToBones, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_ApplyForceToBones, TEXT("ToolTip"), TEXT("If skeletal mesh with physics asset, it will apply buoyancy force at the COM of each bone instead of using the test point array."));
				MetaData->SetValue(NewProp_TestPoints, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_TestPoints, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_TestPoints, TEXT("ToolTip"), TEXT("Test point array. At least one point is required for buoyancy."));
				MetaData->SetValue(NewProp_TestPointRadius, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_TestPointRadius, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_TestPointRadius, TEXT("ToolTip"), TEXT("Radius of the points."));
				MetaData->SetValue(NewProp_MaxUnderwaterVelocity, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_MaxUnderwaterVelocity, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_ClampMaxVelocity, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_ClampMaxVelocity, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_VelocityDamper, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_VelocityDamper, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_FluidAngularDamping, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_FluidAngularDamping, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_FluidAngularDamping, TEXT("ToolTip"), TEXT("Angular damping when object is in fluid."));
				MetaData->SetValue(NewProp_FluidLinearDamping, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_FluidLinearDamping, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_FluidLinearDamping, TEXT("ToolTip"), TEXT("Linear damping when object is in fluid."));
				MetaData->SetValue(NewProp_FluidDensity, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_FluidDensity, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_FluidDensity, TEXT("ToolTip"), TEXT("Density of water. Typically you don't need to change this."));
				MetaData->SetValue(NewProp_MeshDensity, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_MeshDensity, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_MeshDensity, TEXT("ToolTip"), TEXT("Density of mesh."));
				MetaData->SetValue(NewProp_OceanManager, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_OceanManager, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyancyForceComponent.h"));
				MetaData->SetValue(NewProp_OceanManager, TEXT("ToolTip"), TEXT("OceanManager used by the component, if unassigned component will auto-detect"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UBuoyancyForceComponent(Z_Construct_UClass_UBuoyancyForceComponent, &UBuoyancyForceComponent::StaticClass, TEXT("UBuoyancyForceComponent"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UBuoyancyForceComponent);
	UClass* Z_Construct_UClass_UBuoyantDestructibleComponent_NoRegister()
	{
		return UBuoyantDestructibleComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UBuoyantDestructibleComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UDestructibleComponent();
			Z_Construct_UPackage__Script_OceanPlugin();
			OuterClass = UBuoyantDestructibleComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B01080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_ChunkStabilizationThreshold = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ChunkStabilizationThreshold"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ChunkStabilizationThreshold, UBuoyantDestructibleComponent), 0x0010000000000005);
				UProperty* NewProp_ChunkSleepThreshold = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ChunkSleepThreshold"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ChunkSleepThreshold, UBuoyantDestructibleComponent), 0x0010000000000005);
				UProperty* NewProp_WaveForceMultiplier = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("WaveForceMultiplier"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(WaveForceMultiplier, UBuoyantDestructibleComponent), 0x0010040000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(EnableWaveForces, UBuoyantDestructibleComponent, bool);
				UProperty* NewProp_EnableWaveForces = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("EnableWaveForces"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(EnableWaveForces, UBuoyantDestructibleComponent), 0x0010040000000005, CPP_BOOL_PROPERTY_BITMASK(EnableWaveForces, UBuoyantDestructibleComponent), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(DrawDebugPoints, UBuoyantDestructibleComponent, bool);
				UProperty* NewProp_DrawDebugPoints = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DrawDebugPoints"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(DrawDebugPoints, UBuoyantDestructibleComponent), 0x0010040000000005, CPP_BOOL_PROPERTY_BITMASK(DrawDebugPoints, UBuoyantDestructibleComponent), sizeof(bool), true);
				UProperty* NewProp_TestPointRadius = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TestPointRadius"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(TestPointRadius, UBuoyantDestructibleComponent), 0x0010000000000005);
				UProperty* NewProp_MaxUnderwaterVelocity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxUnderwaterVelocity"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(MaxUnderwaterVelocity, UBuoyantDestructibleComponent), 0x0010000000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(ClampMaxVelocity, UBuoyantDestructibleComponent, bool);
				UProperty* NewProp_ClampMaxVelocity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ClampMaxVelocity"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ClampMaxVelocity, UBuoyantDestructibleComponent), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(ClampMaxVelocity, UBuoyantDestructibleComponent), sizeof(bool), true);
				UProperty* NewProp_VelocityDamper = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("VelocityDamper"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(VelocityDamper, UBuoyantDestructibleComponent), 0x0010040000000005, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_FluidAngularDamping = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FluidAngularDamping"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(FluidAngularDamping, UBuoyantDestructibleComponent), 0x0010000000000005);
				UProperty* NewProp_FluidLinearDamping = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FluidLinearDamping"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(FluidLinearDamping, UBuoyantDestructibleComponent), 0x0010000000000005);
				UProperty* NewProp_FluidDensity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FluidDensity"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(FluidDensity, UBuoyantDestructibleComponent), 0x0010000000000005);
				UProperty* NewProp_ChunkDensity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ChunkDensity"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ChunkDensity, UBuoyantDestructibleComponent), 0x0010000000000005);
				UProperty* NewProp_OceanManager = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OceanManager"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(OceanManager, UBuoyantDestructibleComponent), 0x0010040000000005, Z_Construct_UClass_AOceanManager_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->ClassConfigName = FName(TEXT("Engine"));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Physics"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Mesh Components|SkinnedMesh Mirroring Activation Components|Activation Object Mesh Components|SkinnedMesh Mirroring Activation Components|Activation Object Mobility Trigger"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("BuoyantDestructibleComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantDestructibleComponent.h"));
				MetaData->SetValue(NewProp_ChunkStabilizationThreshold, TEXT("Category"), TEXT("Advanced"));
				MetaData->SetValue(NewProp_ChunkStabilizationThreshold, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantDestructibleComponent.h"));
				MetaData->SetValue(NewProp_ChunkStabilizationThreshold, TEXT("ToolTip"), TEXT("* Sets the mass-normalized kinetic energy threshold below which an actor may participate in stabilization.\n* (This value has no effect if PxSceneFlag::eENABLE_STABILIZATION was not enabled on the PxSceneDesc)"));
				MetaData->SetValue(NewProp_ChunkSleepThreshold, TEXT("Category"), TEXT("Advanced"));
				MetaData->SetValue(NewProp_ChunkSleepThreshold, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantDestructibleComponent.h"));
				MetaData->SetValue(NewProp_ChunkSleepThreshold, TEXT("ToolTip"), TEXT("* Sets the mass-normalized kinetic energy threshold below which an actor may go to sleep.\n* Default physx value is ~50.0f (we set it 0 to avoid weird sleeping chunks on water)."));
				MetaData->SetValue(NewProp_WaveForceMultiplier, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_WaveForceMultiplier, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantDestructibleComponent.h"));
				MetaData->SetValue(NewProp_EnableWaveForces, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_EnableWaveForces, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantDestructibleComponent.h"));
				MetaData->SetValue(NewProp_DrawDebugPoints, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_DrawDebugPoints, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantDestructibleComponent.h"));
				MetaData->SetValue(NewProp_TestPointRadius, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_TestPointRadius, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantDestructibleComponent.h"));
				MetaData->SetValue(NewProp_TestPointRadius, TEXT("ToolTip"), TEXT("Radius of the test point"));
				MetaData->SetValue(NewProp_MaxUnderwaterVelocity, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_MaxUnderwaterVelocity, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantDestructibleComponent.h"));
				MetaData->SetValue(NewProp_ClampMaxVelocity, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_ClampMaxVelocity, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantDestructibleComponent.h"));
				MetaData->SetValue(NewProp_VelocityDamper, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_VelocityDamper, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantDestructibleComponent.h"));
				MetaData->SetValue(NewProp_FluidAngularDamping, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_FluidAngularDamping, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantDestructibleComponent.h"));
				MetaData->SetValue(NewProp_FluidAngularDamping, TEXT("ToolTip"), TEXT("Angular damping when chunk is in fluid"));
				MetaData->SetValue(NewProp_FluidLinearDamping, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_FluidLinearDamping, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantDestructibleComponent.h"));
				MetaData->SetValue(NewProp_FluidLinearDamping, TEXT("ToolTip"), TEXT("Linear damping when chunk is in fluid"));
				MetaData->SetValue(NewProp_FluidDensity, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_FluidDensity, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantDestructibleComponent.h"));
				MetaData->SetValue(NewProp_FluidDensity, TEXT("ToolTip"), TEXT("Density of water"));
				MetaData->SetValue(NewProp_ChunkDensity, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_ChunkDensity, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantDestructibleComponent.h"));
				MetaData->SetValue(NewProp_ChunkDensity, TEXT("ToolTip"), TEXT("Density of each chunk"));
				MetaData->SetValue(NewProp_OceanManager, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_OceanManager, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantDestructibleComponent.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UBuoyantDestructibleComponent(Z_Construct_UClass_UBuoyantDestructibleComponent, &UBuoyantDestructibleComponent::StaticClass, TEXT("UBuoyantDestructibleComponent"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UBuoyantDestructibleComponent);
	UClass* Z_Construct_UClass_ABuoyantDestructible_NoRegister()
	{
		return ABuoyantDestructible::StaticClass();
	}
	UClass* Z_Construct_UClass_ABuoyantDestructible()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AActor();
			Z_Construct_UPackage__Script_OceanPlugin();
			OuterClass = ABuoyantDestructible::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_BuoyantDestructibleComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BuoyantDestructibleComponent"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(BuoyantDestructibleComponent, ABuoyantDestructible), 0x00100000000a001d, Z_Construct_UClass_UBuoyantDestructibleComponent_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("BuoyantDestructible.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantDestructible.h"));
				MetaData->SetValue(NewProp_BuoyantDestructibleComponent, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_BuoyantDestructibleComponent, TEXT("Category"), TEXT("BuoyantDestructible"));
				MetaData->SetValue(NewProp_BuoyantDestructibleComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_BuoyantDestructibleComponent, TEXT("ExposeFunctionCategories"), TEXT("Destruction,Components|Destructible,Buoyancy Settings,Advanced"));
				MetaData->SetValue(NewProp_BuoyantDestructibleComponent, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantDestructible.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ABuoyantDestructible(Z_Construct_UClass_ABuoyantDestructible, &ABuoyantDestructible::StaticClass, TEXT("ABuoyantDestructible"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(ABuoyantDestructible);
	UClass* Z_Construct_UClass_UBuoyantMeshComponent_NoRegister()
	{
		return UBuoyantMeshComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UBuoyantMeshComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UStaticMeshComponent();
			Z_Construct_UPackage__Script_OceanPlugin();
			OuterClass = UBuoyantMeshComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B01080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_WaterHeightmap = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("WaterHeightmap"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(WaterHeightmap, UBuoyantMeshComponent), 0x0040000000080008, Z_Construct_UClass_UWaterHeightmapComponent_NoRegister());
				UProperty* NewProp_WaterDensity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("WaterDensity"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(WaterDensity, UBuoyantMeshComponent), 0x0010000000000005);
				UProperty* NewProp_Mass = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Mass"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Mass, UBuoyantMeshComponent), 0x0010000000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bOverrideMass, UBuoyantMeshComponent, bool);
				UProperty* NewProp_bOverrideMass = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bOverrideMass"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bOverrideMass, UBuoyantMeshComponent), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bOverrideMass, UBuoyantMeshComponent), sizeof(bool), true);
				UProperty* NewProp_MeshDensity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MeshDensity"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(MeshDensity, UBuoyantMeshComponent), 0x0010000000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bOverrideMeshDensity, UBuoyantMeshComponent, bool);
				UProperty* NewProp_bOverrideMeshDensity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bOverrideMeshDensity"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bOverrideMeshDensity, UBuoyantMeshComponent), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bOverrideMeshDensity, UBuoyantMeshComponent), sizeof(bool), true);
				UProperty* NewProp_ForceArrowSize = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ForceArrowSize"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ForceArrowSize, UBuoyantMeshComponent), 0x0010000000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bDrawSubtriangles, UBuoyantMeshComponent, bool);
				UProperty* NewProp_bDrawSubtriangles = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bDrawSubtriangles"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bDrawSubtriangles, UBuoyantMeshComponent), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bDrawSubtriangles, UBuoyantMeshComponent), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bDrawTriangles, UBuoyantMeshComponent, bool);
				UProperty* NewProp_bDrawTriangles = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bDrawTriangles"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bDrawTriangles, UBuoyantMeshComponent), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bDrawTriangles, UBuoyantMeshComponent), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bDrawVertices, UBuoyantMeshComponent, bool);
				UProperty* NewProp_bDrawVertices = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bDrawVertices"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bDrawVertices, UBuoyantMeshComponent), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bDrawVertices, UBuoyantMeshComponent), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bDrawWaterline, UBuoyantMeshComponent, bool);
				UProperty* NewProp_bDrawWaterline = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bDrawWaterline"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bDrawWaterline, UBuoyantMeshComponent), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bDrawWaterline, UBuoyantMeshComponent), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bDrawForceArrows, UBuoyantMeshComponent, bool);
				UProperty* NewProp_bDrawForceArrows = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bDrawForceArrows"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bDrawForceArrows, UBuoyantMeshComponent), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bDrawForceArrows, UBuoyantMeshComponent), sizeof(bool), true);
				UProperty* NewProp_OceanManager = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OceanManager"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(OceanManager, UBuoyantMeshComponent), 0x0010040000000005, Z_Construct_UClass_AOceanManager_NoRegister());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseDynamicForces, UBuoyantMeshComponent, bool);
				UProperty* NewProp_bUseDynamicForces = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUseDynamicForces"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseDynamicForces, UBuoyantMeshComponent), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bUseDynamicForces, UBuoyantMeshComponent), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseStaticForces, UBuoyantMeshComponent, bool);
				UProperty* NewProp_bUseStaticForces = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUseStaticForces"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseStaticForces, UBuoyantMeshComponent), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bUseStaticForces, UBuoyantMeshComponent), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bUseWaterPatch, UBuoyantMeshComponent, bool);
				UProperty* NewProp_bUseWaterPatch = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bUseWaterPatch"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bUseWaterPatch, UBuoyantMeshComponent), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bUseWaterPatch, UBuoyantMeshComponent), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bVerticalForcesOnly, UBuoyantMeshComponent, bool);
				UProperty* NewProp_bVerticalForcesOnly = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bVerticalForcesOnly"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bVerticalForcesOnly, UBuoyantMeshComponent), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bVerticalForcesOnly, UBuoyantMeshComponent), sizeof(bool), true);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->ClassConfigName = FName(TEXT("Engine"));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Physics"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Activation Components|Activation Trigger"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("BuoyantMesh/BuoyantMeshComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantMesh/BuoyantMeshComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("This component applies to the root component buoyancy forces modeled from a static mesh.\nThe algorithm used is described in \"Water interaction model for boats in video\ngames\" by Jacques Kerner.\nhttp://gamasutra.com/view/news/237528/Water_interaction_model_for_boats_in_video_games.php\n\nIn addition, support for dynamic (drag) forces is included."));
				MetaData->SetValue(NewProp_WaterHeightmap, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_WaterHeightmap, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantMesh/BuoyantMeshComponent.h"));
				MetaData->SetValue(NewProp_WaterDensity, TEXT("Category"), TEXT("Mass Settings"));
				MetaData->SetValue(NewProp_WaterDensity, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantMesh/BuoyantMeshComponent.h"));
				MetaData->SetValue(NewProp_WaterDensity, TEXT("ToolTip"), TEXT("Density of the water in kg/uu^3. It is around 0.001027 if 1 unreal unit is 1 cm."));
				MetaData->SetValue(NewProp_Mass, TEXT("Category"), TEXT("Mass Settings"));
				MetaData->SetValue(NewProp_Mass, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantMesh/BuoyantMeshComponent.h"));
				MetaData->SetValue(NewProp_Mass, TEXT("ToolTip"), TEXT("Mass of the rigidbody in kg.\nDoes nothing if bOverrideMass is false."));
				MetaData->SetValue(NewProp_bOverrideMass, TEXT("Category"), TEXT("Mass Settings"));
				MetaData->SetValue(NewProp_bOverrideMass, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantMesh/BuoyantMeshComponent.h"));
				MetaData->SetValue(NewProp_MeshDensity, TEXT("Category"), TEXT("Mass Settings"));
				MetaData->SetValue(NewProp_MeshDensity, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantMesh/BuoyantMeshComponent.h"));
				MetaData->SetValue(NewProp_MeshDensity, TEXT("ToolTip"), TEXT("Density of the mesh in kg/uu^3. The object will sink if it's higher than the water density.\nDoes nothing if bOverrideMeshDensity is false."));
				MetaData->SetValue(NewProp_bOverrideMeshDensity, TEXT("Category"), TEXT("Mass Settings"));
				MetaData->SetValue(NewProp_bOverrideMeshDensity, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantMesh/BuoyantMeshComponent.h"));
				MetaData->SetValue(NewProp_ForceArrowSize, TEXT("Category"), TEXT("Debug"));
				MetaData->SetValue(NewProp_ForceArrowSize, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantMesh/BuoyantMeshComponent.h"));
				MetaData->SetValue(NewProp_ForceArrowSize, TEXT("ToolTip"), TEXT("Force arrow size multiplier."));
				MetaData->SetValue(NewProp_bDrawSubtriangles, TEXT("Category"), TEXT("Debug"));
				MetaData->SetValue(NewProp_bDrawSubtriangles, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantMesh/BuoyantMeshComponent.h"));
				MetaData->SetValue(NewProp_bDrawSubtriangles, TEXT("ToolTip"), TEXT("Draw the submerged triangles?"));
				MetaData->SetValue(NewProp_bDrawTriangles, TEXT("Category"), TEXT("Debug"));
				MetaData->SetValue(NewProp_bDrawTriangles, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantMesh/BuoyantMeshComponent.h"));
				MetaData->SetValue(NewProp_bDrawTriangles, TEXT("ToolTip"), TEXT("Draw the original mesh triangles?"));
				MetaData->SetValue(NewProp_bDrawVertices, TEXT("Category"), TEXT("Debug"));
				MetaData->SetValue(NewProp_bDrawVertices, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantMesh/BuoyantMeshComponent.h"));
				MetaData->SetValue(NewProp_bDrawVertices, TEXT("ToolTip"), TEXT("Draw the mesh vertices?"));
				MetaData->SetValue(NewProp_bDrawWaterline, TEXT("Category"), TEXT("Debug"));
				MetaData->SetValue(NewProp_bDrawWaterline, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantMesh/BuoyantMeshComponent.h"));
				MetaData->SetValue(NewProp_bDrawWaterline, TEXT("ToolTip"), TEXT("Draw the waterline on the mesh?"));
				MetaData->SetValue(NewProp_bDrawForceArrows, TEXT("Category"), TEXT("Debug"));
				MetaData->SetValue(NewProp_bDrawForceArrows, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantMesh/BuoyantMeshComponent.h"));
				MetaData->SetValue(NewProp_bDrawForceArrows, TEXT("ToolTip"), TEXT("Draw arrows representing the buoyancy forces pushing on the mesh?\nThe length is proportional to the force magnitude."));
				MetaData->SetValue(NewProp_OceanManager, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_OceanManager, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantMesh/BuoyantMeshComponent.h"));
				MetaData->SetValue(NewProp_OceanManager, TEXT("ToolTip"), TEXT("OceanManager used by the component, if unassigned component will auto-detect."));
				MetaData->SetValue(NewProp_bUseDynamicForces, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_bUseDynamicForces, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantMesh/BuoyantMeshComponent.h"));
				MetaData->SetValue(NewProp_bUseDynamicForces, TEXT("ToolTip"), TEXT("Use hydrodynamic (drag) forces if true."));
				MetaData->SetValue(NewProp_bUseStaticForces, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_bUseStaticForces, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantMesh/BuoyantMeshComponent.h"));
				MetaData->SetValue(NewProp_bUseStaticForces, TEXT("ToolTip"), TEXT("Use hydrostatic (buoyancy) forces if true."));
				MetaData->SetValue(NewProp_bUseWaterPatch, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_bUseWaterPatch, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantMesh/BuoyantMeshComponent.h"));
				MetaData->SetValue(NewProp_bUseWaterPatch, TEXT("ToolTip"), TEXT("Use a WaterPatchComponent to possibly improve performance.\nThis actor needs a WaterPatchComponent for this to work."));
				MetaData->SetValue(NewProp_bVerticalForcesOnly, TEXT("Category"), TEXT("Buoyancy Settings"));
				MetaData->SetValue(NewProp_bVerticalForcesOnly, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantMesh/BuoyantMeshComponent.h"));
				MetaData->SetValue(NewProp_bVerticalForcesOnly, TEXT("ToolTip"), TEXT("Only use the vertical component of the buoyancy forces."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UBuoyantMeshComponent(Z_Construct_UClass_UBuoyantMeshComponent, &UBuoyantMeshComponent::StaticClass, TEXT("UBuoyantMeshComponent"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UBuoyantMeshComponent);
	UFunction* Z_Construct_UFunction_ACustomVehicleController_DrawBuoyancyPoints()
	{
		UObject* Outer=Z_Construct_UClass_ACustomVehicleController();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("DrawBuoyancyPoints"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x00020600, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/CustomVehicleController.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("--Custom debugging console commands--"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ACustomVehicleController_EnableBuoyancy()
	{
		UObject* Outer=Z_Construct_UClass_ACustomVehicleController();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EnableBuoyancy"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x00020600, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/CustomVehicleController.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ACustomVehicleController_EnterVehicle()
	{
		struct CustomVehicleController_eventEnterVehicle_Parms
		{
			APawn* Vehicle;
		};
		UObject* Outer=Z_Construct_UClass_ACustomVehicleController();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EnterVehicle"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(CustomVehicleController_eventEnterVehicle_Parms));
			UProperty* NewProp_Vehicle = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Vehicle"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Vehicle, CustomVehicleController_eventEnterVehicle_Parms), 0x0010000000000080, Z_Construct_UClass_APawn_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Vehicle"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/CustomVehicleController.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ACustomVehicleController_ExitVehicle()
	{
		UObject* Outer=Z_Construct_UClass_ACustomVehicleController();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ExitVehicle"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Vehicle"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/CustomVehicleController.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ACustomVehicleController_GetIsDriving()
	{
		struct CustomVehicleController_eventGetIsDriving_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ACustomVehicleController();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetIsDriving"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14020400, 65535, sizeof(CustomVehicleController_eventGetIsDriving_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, CustomVehicleController_eventGetIsDriving_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, CustomVehicleController_eventGetIsDriving_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, CustomVehicleController_eventGetIsDriving_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Vehicle"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/CustomVehicleController.h"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_ACustomVehicleController_NoRegister()
	{
		return ACustomVehicleController::StaticClass();
	}
	UClass* Z_Construct_UClass_ACustomVehicleController()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_APlayerController();
			Z_Construct_UPackage__Script_OceanPlugin();
			OuterClass = ACustomVehicleController::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20900284;

				OuterClass->LinkChild(Z_Construct_UFunction_ACustomVehicleController_DrawBuoyancyPoints());
				OuterClass->LinkChild(Z_Construct_UFunction_ACustomVehicleController_EnableBuoyancy());
				OuterClass->LinkChild(Z_Construct_UFunction_ACustomVehicleController_EnterVehicle());
				OuterClass->LinkChild(Z_Construct_UFunction_ACustomVehicleController_ExitVehicle());
				OuterClass->LinkChild(Z_Construct_UFunction_ACustomVehicleController_GetIsDriving());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_PlayerPawn = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PlayerPawn"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PlayerPawn, ACustomVehicleController), 0x0040000000000020, Z_Construct_UClass_APawn_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ACustomVehicleController_DrawBuoyancyPoints(), "DrawBuoyancyPoints"); // 4206936511
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ACustomVehicleController_EnableBuoyancy(), "EnableBuoyancy"); // 597773343
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ACustomVehicleController_EnterVehicle(), "EnterVehicle"); // 2809493767
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ACustomVehicleController_ExitVehicle(), "ExitVehicle"); // 1438223564
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ACustomVehicleController_GetIsDriving(), "GetIsDriving"); // 3532733319
				OuterClass->ClassConfigName = FName(TEXT("Game"));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Collision Rendering Utilities|Transformation"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("CustomVehicleController.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/CustomVehicleController.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Custom player controller that has custom functionality to help possess vehicles."));
				MetaData->SetValue(NewProp_PlayerPawn, TEXT("ModuleRelativePath"), TEXT("Classes/CustomVehicleController.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ACustomVehicleController(Z_Construct_UClass_ACustomVehicleController, &ACustomVehicleController::StaticClass, TEXT("ACustomVehicleController"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(ACustomVehicleController);
	UClass* Z_Construct_UClass_AFishManager_NoRegister()
	{
		return AFishManager::StaticClass();
	}
	UClass* Z_Construct_UClass_AFishManager()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AActor();
			Z_Construct_UPackage__Script_OceanPlugin();
			OuterClass = AFishManager::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20800080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_playerType = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("playerType"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(playerType, AFishManager), 0x0010000000000005, Z_Construct_UClass_UObject_NoRegister(), UClass::StaticClass());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(DebugMode, AFishManager, bool);
				UProperty* NewProp_DebugMode = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DebugMode"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(DebugMode, AFishManager), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(DebugMode, AFishManager), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(attachToPlayer, AFishManager, bool);
				UProperty* NewProp_attachToPlayer = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("attachToPlayer"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(attachToPlayer, AFishManager), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(attachToPlayer, AFishManager), sizeof(bool), true);
				UProperty* NewProp_underwaterBoxLength = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("underwaterBoxLength"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(underwaterBoxLength, AFishManager), 0x0010000000000005);
				UProperty* NewProp_maxZ = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("maxZ"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(maxZ, AFishManager), 0x0010000000000005);
				UProperty* NewProp_minZ = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("minZ"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(minZ, AFishManager), 0x0010000000000005);
				UProperty* NewProp_numInFlock = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("numInFlock"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(numInFlock, AFishManager), 0x0010000000000005);
				UProperty* NewProp_numInFlock_Inner = new(EC_InternalUseOnlyConstructor, NewProp_numInFlock, TEXT("numInFlock"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000);
				UProperty* NewProp_flockTypes = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("flockTypes"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(flockTypes, AFishManager), 0x0010000000000005);
				UProperty* NewProp_flockTypes_Inner = new(EC_InternalUseOnlyConstructor, NewProp_flockTypes, TEXT("flockTypes"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_UObject_NoRegister(), UClass::StaticClass());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Fish/FishManager.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FishManager.h"));
				MetaData->SetValue(OuterClass, TEXT("ObjectInitializerConstructorDeclared"), TEXT(""));
				MetaData->SetValue(NewProp_playerType, TEXT("Category"), TEXT("Config"));
				MetaData->SetValue(NewProp_playerType, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FishManager.h"));
				MetaData->SetValue(NewProp_playerType, TEXT("ToolTip"), TEXT("Player Type"));
				MetaData->SetValue(NewProp_DebugMode, TEXT("Category"), TEXT("Config"));
				MetaData->SetValue(NewProp_DebugMode, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FishManager.h"));
				MetaData->SetValue(NewProp_DebugMode, TEXT("ToolTip"), TEXT("Player Type"));
				MetaData->SetValue(NewProp_attachToPlayer, TEXT("Category"), TEXT("Config"));
				MetaData->SetValue(NewProp_attachToPlayer, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FishManager.h"));
				MetaData->SetValue(NewProp_attachToPlayer, TEXT("ToolTip"), TEXT("Attach fish manager to player?"));
				MetaData->SetValue(NewProp_underwaterBoxLength, TEXT("Category"), TEXT("Config"));
				MetaData->SetValue(NewProp_underwaterBoxLength, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FishManager.h"));
				MetaData->SetValue(NewProp_underwaterBoxLength, TEXT("ToolTip"), TEXT("Length of underwater box"));
				MetaData->SetValue(NewProp_maxZ, TEXT("Category"), TEXT("Config"));
				MetaData->SetValue(NewProp_maxZ, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FishManager.h"));
				MetaData->SetValue(NewProp_maxZ, TEXT("ToolTip"), TEXT("max Z of volume that is considered underwater"));
				MetaData->SetValue(NewProp_minZ, TEXT("Category"), TEXT("Config"));
				MetaData->SetValue(NewProp_minZ, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FishManager.h"));
				MetaData->SetValue(NewProp_minZ, TEXT("ToolTip"), TEXT("min Z of volume that is considered underwater"));
				MetaData->SetValue(NewProp_numInFlock, TEXT("Category"), TEXT("Config"));
				MetaData->SetValue(NewProp_numInFlock, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FishManager.h"));
				MetaData->SetValue(NewProp_numInFlock, TEXT("ToolTip"), TEXT("# of fish in respective flock"));
				MetaData->SetValue(NewProp_flockTypes, TEXT("Category"), TEXT("Config"));
				MetaData->SetValue(NewProp_flockTypes, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FishManager.h"));
				MetaData->SetValue(NewProp_flockTypes, TEXT("ToolTip"), TEXT("Type of flocks to spawn"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AFishManager(Z_Construct_UClass_AFishManager, &AFishManager::StaticClass, TEXT("AFishManager"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(AFishManager);
	UFunction* Z_Construct_UFunction_AFlockFish_OnBeginOverlap()
	{
		struct FlockFish_eventOnBeginOverlap_Parms
		{
			UPrimitiveComponent* activatedComp;
			AActor* otherActor;
			UPrimitiveComponent* otherComp;
			int32 otherBodyIndex;
			bool bFromSweep;
			FHitResult sweepResult;
		};
		UObject* Outer=Z_Construct_UClass_AFlockFish();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnBeginOverlap"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x00480401, 65535, sizeof(FlockFish_eventOnBeginOverlap_Parms));
			UProperty* NewProp_sweepResult = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("sweepResult"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(sweepResult, FlockFish_eventOnBeginOverlap_Parms), 0x0010008008000182, Z_Construct_UScriptStruct_FHitResult());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(bFromSweep, FlockFish_eventOnBeginOverlap_Parms, bool);
			UProperty* NewProp_bFromSweep = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("bFromSweep"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bFromSweep, FlockFish_eventOnBeginOverlap_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(bFromSweep, FlockFish_eventOnBeginOverlap_Parms), sizeof(bool), true);
			UProperty* NewProp_otherBodyIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("otherBodyIndex"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(otherBodyIndex, FlockFish_eventOnBeginOverlap_Parms), 0x0010000000000080);
			UProperty* NewProp_otherComp = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("otherComp"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(otherComp, FlockFish_eventOnBeginOverlap_Parms), 0x0010000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			UProperty* NewProp_otherActor = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("otherActor"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(otherActor, FlockFish_eventOnBeginOverlap_Parms), 0x0010000000000080, Z_Construct_UClass_AActor_NoRegister());
			UProperty* NewProp_activatedComp = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("activatedComp"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(activatedComp, FlockFish_eventOnBeginOverlap_Parms), 0x0010000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
			MetaData->SetValue(NewProp_sweepResult, TEXT("NativeConst"), TEXT(""));
			MetaData->SetValue(NewProp_otherComp, TEXT("EditInline"), TEXT("true"));
			MetaData->SetValue(NewProp_activatedComp, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_AFlockFish_OnEndOverlap()
	{
		struct FlockFish_eventOnEndOverlap_Parms
		{
			UPrimitiveComponent* activatedComp;
			AActor* otherActor;
			UPrimitiveComponent* otherComp;
			int32 otherBodyIndex;
		};
		UObject* Outer=Z_Construct_UClass_AFlockFish();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnEndOverlap"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x00080401, 65535, sizeof(FlockFish_eventOnEndOverlap_Parms));
			UProperty* NewProp_otherBodyIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("otherBodyIndex"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(otherBodyIndex, FlockFish_eventOnEndOverlap_Parms), 0x0010000000000080);
			UProperty* NewProp_otherComp = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("otherComp"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(otherComp, FlockFish_eventOnEndOverlap_Parms), 0x0010000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			UProperty* NewProp_otherActor = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("otherActor"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(otherActor, FlockFish_eventOnEndOverlap_Parms), 0x0010000000000080, Z_Construct_UClass_AActor_NoRegister());
			UProperty* NewProp_activatedComp = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("activatedComp"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(activatedComp, FlockFish_eventOnEndOverlap_Parms), 0x0010000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
			MetaData->SetValue(NewProp_otherComp, TEXT("EditInline"), TEXT("true"));
			MetaData->SetValue(NewProp_activatedComp, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_AFlockFish_NoRegister()
	{
		return AFlockFish::StaticClass();
	}
	UClass* Z_Construct_UClass_AFlockFish()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_APawn();
			Z_Construct_UPackage__Script_OceanPlugin();
			OuterClass = AFlockFish::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20800080;

				OuterClass->LinkChild(Z_Construct_UFunction_AFlockFish_OnBeginOverlap());
				OuterClass->LinkChild(Z_Construct_UFunction_AFlockFish_OnEndOverlap());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(DebugMode, AFlockFish, bool);
				UProperty* NewProp_DebugMode = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DebugMode"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(DebugMode, AFlockFish), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(DebugMode, AFlockFish), sizeof(bool), true);
				UProperty* NewProp_UpdateEveryTick = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("UpdateEveryTick"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(UpdateEveryTick, AFlockFish), 0x0010000000000005);
				UProperty* NewProp_NumNeighborsToEvaluate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("NumNeighborsToEvaluate"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(NumNeighborsToEvaluate, AFlockFish), 0x0010000000000005);
				UProperty* NewProp_CustomZSeekMax = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CustomZSeekMax"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(CustomZSeekMax, AFlockFish), 0x0010000000000005);
				UProperty* NewProp_CustomZSeekMin = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CustomZSeekMin"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(CustomZSeekMin, AFlockFish), 0x0010000000000005);
				UProperty* NewProp_underwaterMax = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("underwaterMax"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(underwaterMax, AFlockFish), 0x0010000000000005, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_underwaterMin = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("underwaterMin"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(underwaterMin, AFlockFish), 0x0010000000000005, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_playerType = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("playerType"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(playerType, AFlockFish), 0x0010000000000005, Z_Construct_UClass_UObject_NoRegister(), UClass::StaticClass());
				UProperty* NewProp_AvoidanceForce = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AvoidanceForce"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(AvoidanceForce, AFlockFish), 0x0010000000000005);
				UProperty* NewProp_AvoidForceMultiplier = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("AvoidForceMultiplier"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(AvoidForceMultiplier, AFlockFish), 0x0010000000000005);
				UProperty* NewProp_SeekDecelerationMultiplier = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SeekDecelerationMultiplier"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(SeekDecelerationMultiplier, AFlockFish), 0x0010000000000005);
				UProperty* NewProp_ChaseAccelerationMultiplier = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ChaseAccelerationMultiplier"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ChaseAccelerationMultiplier, AFlockFish), 0x0010000000000005);
				UProperty* NewProp_FleeAccelerationMultiplier = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FleeAccelerationMultiplier"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(FleeAccelerationMultiplier, AFlockFish), 0x0010000000000005);
				UProperty* NewProp_FleeDistanceMultiplier = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FleeDistanceMultiplier"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(FleeDistanceMultiplier, AFlockFish), 0x0010000000000005);
				UProperty* NewProp_SeperationDistanceMultiplier = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SeperationDistanceMultiplier"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(SeperationDistanceMultiplier, AFlockFish), 0x0010000000000005);
				UProperty* NewProp_distBehindSpeedUpRange = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("distBehindSpeedUpRange"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(distBehindSpeedUpRange, AFlockFish), 0x0010000000000005);
				UProperty* NewProp_hungerResetTime = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("hungerResetTime"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(hungerResetTime, AFlockFish), 0x0010000000000005);
				UProperty* NewProp_turnFrequency = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("turnFrequency"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(turnFrequency, AFlockFish), 0x0010000000000005);
				UProperty* NewProp_turnSpeed = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("turnSpeed"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(turnSpeed, AFlockFish), 0x0010000000000005);
				UProperty* NewProp_maxSpeed = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("maxSpeed"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(maxSpeed, AFlockFish), 0x0010000000000005);
				UProperty* NewProp_speed = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("speed"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(speed, AFlockFish), 0x0010000000000005);
				UProperty* NewProp_followDist = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("followDist"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(followDist, AFlockFish), 0x0010000000000005);
				UProperty* NewProp_neighborType = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("neighborType"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(CPP_PROPERTY_BASE(neighborType, AFlockFish), 0x0010000000000005, Z_Construct_UClass_UObject_NoRegister(), UClass::StaticClass());
				UProperty* NewProp_preyTypes = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("preyTypes"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(preyTypes, AFlockFish), 0x0010000000000005);
				UProperty* NewProp_preyTypes_Inner = new(EC_InternalUseOnlyConstructor, NewProp_preyTypes, TEXT("preyTypes"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_UObject_NoRegister(), UClass::StaticClass());
				UProperty* NewProp_enemyTypes = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("enemyTypes"), RF_Public|RF_Transient|RF_MarkAsNative) UArrayProperty(CPP_PROPERTY_BASE(enemyTypes, AFlockFish), 0x0010000000000005);
				UProperty* NewProp_enemyTypes_Inner = new(EC_InternalUseOnlyConstructor, NewProp_enemyTypes, TEXT("enemyTypes"), RF_Public|RF_Transient|RF_MarkAsNative) UClassProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_UObject_NoRegister(), UClass::StaticClass());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(isLeader, AFlockFish, bool);
				UProperty* NewProp_isLeader = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("isLeader"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(isLeader, AFlockFish), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(isLeader, AFlockFish), sizeof(bool), true);
				UProperty* NewProp_FishInteractionSphere = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FishInteractionSphere"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(FishInteractionSphere, AFlockFish), 0x00400000000a001d, Z_Construct_UClass_USphereComponent_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AFlockFish_OnBeginOverlap(), "OnBeginOverlap"); // 9154039
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_AFlockFish_OnEndOverlap(), "OnEndOverlap"); // 627126977
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Navigation"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Fish/FlockFish.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(OuterClass, TEXT("ObjectInitializerConstructorDeclared"), TEXT(""));
				MetaData->SetValue(NewProp_DebugMode, TEXT("Category"), TEXT("TESTING"));
				MetaData->SetValue(NewProp_DebugMode, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_DebugMode, TEXT("ToolTip"), TEXT("Run fish in debug mode"));
				MetaData->SetValue(NewProp_UpdateEveryTick, TEXT("Category"), TEXT("Optimization"));
				MetaData->SetValue(NewProp_UpdateEveryTick, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_UpdateEveryTick, TEXT("ToolTip"), TEXT("When set to 0, update every tick, otherwise update after specified time"));
				MetaData->SetValue(NewProp_NumNeighborsToEvaluate, TEXT("Category"), TEXT("Optimization"));
				MetaData->SetValue(NewProp_NumNeighborsToEvaluate, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_NumNeighborsToEvaluate, TEXT("ToolTip"), TEXT("Max number of neighbors to evaluate on a Tick (0 for all neighbors)"));
				MetaData->SetValue(NewProp_CustomZSeekMax, TEXT("Category"), TEXT("Environment Variables"));
				MetaData->SetValue(NewProp_CustomZSeekMax, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_CustomZSeekMax, TEXT("ToolTip"), TEXT("Custom Z range for targeting (NULL will use full range of min/max)"));
				MetaData->SetValue(NewProp_CustomZSeekMin, TEXT("Category"), TEXT("Environment Variables"));
				MetaData->SetValue(NewProp_CustomZSeekMin, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_CustomZSeekMin, TEXT("ToolTip"), TEXT("Custom Z range for targeting (NULL will use full range of min/max)"));
				MetaData->SetValue(NewProp_underwaterMax, TEXT("Category"), TEXT("Environment Variables"));
				MetaData->SetValue(NewProp_underwaterMax, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_underwaterMax, TEXT("ToolTip"), TEXT("volume that is considered underwater"));
				MetaData->SetValue(NewProp_underwaterMin, TEXT("Category"), TEXT("Environment Variables"));
				MetaData->SetValue(NewProp_underwaterMin, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_underwaterMin, TEXT("ToolTip"), TEXT("volume that is considered underwater"));
				MetaData->SetValue(NewProp_playerType, TEXT("Category"), TEXT("Environment Variables"));
				MetaData->SetValue(NewProp_playerType, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_playerType, TEXT("ToolTip"), TEXT("Player the fish will avoid"));
				MetaData->SetValue(NewProp_AvoidanceForce, TEXT("Category"), TEXT("Advanced Settings"));
				MetaData->SetValue(NewProp_AvoidanceForce, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_AvoidanceForce, TEXT("ToolTip"), TEXT("Avoidance force"));
				MetaData->SetValue(NewProp_AvoidForceMultiplier, TEXT("Category"), TEXT("Advanced Settings"));
				MetaData->SetValue(NewProp_AvoidForceMultiplier, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_AvoidForceMultiplier, TEXT("ToolTip"), TEXT("Avoid Distance Multiplier"));
				MetaData->SetValue(NewProp_SeekDecelerationMultiplier, TEXT("Category"), TEXT("Advanced Settings"));
				MetaData->SetValue(NewProp_SeekDecelerationMultiplier, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_SeekDecelerationMultiplier, TEXT("ToolTip"), TEXT("Multiplies with delta time since last tick when lerping to regular speed (While Seeking)"));
				MetaData->SetValue(NewProp_ChaseAccelerationMultiplier, TEXT("Category"), TEXT("Advanced Settings"));
				MetaData->SetValue(NewProp_ChaseAccelerationMultiplier, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_ChaseAccelerationMultiplier, TEXT("ToolTip"), TEXT("Multiplies with delta time since last tick when lerping to max speed (While Chasing)"));
				MetaData->SetValue(NewProp_FleeAccelerationMultiplier, TEXT("Category"), TEXT("Advanced Settings"));
				MetaData->SetValue(NewProp_FleeAccelerationMultiplier, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_FleeAccelerationMultiplier, TEXT("ToolTip"), TEXT("Multiplies with delta time since last tick when lerping to max speed (While Fleeing)"));
				MetaData->SetValue(NewProp_FleeDistanceMultiplier, TEXT("Category"), TEXT("Advanced Settings"));
				MetaData->SetValue(NewProp_FleeDistanceMultiplier, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_FleeDistanceMultiplier, TEXT("ToolTip"), TEXT("Multiplies With Radius of Fish Interaction Sphere for Flee Distance"));
				MetaData->SetValue(NewProp_SeperationDistanceMultiplier, TEXT("Category"), TEXT("Advanced Settings"));
				MetaData->SetValue(NewProp_SeperationDistanceMultiplier, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_SeperationDistanceMultiplier, TEXT("ToolTip"), TEXT("Multiplies With Radius of Fish Interaction Sphere for neighbor seperation"));
				MetaData->SetValue(NewProp_distBehindSpeedUpRange, TEXT("Category"), TEXT("Fish Attributes"));
				MetaData->SetValue(NewProp_distBehindSpeedUpRange, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_distBehindSpeedUpRange, TEXT("ToolTip"), TEXT("Go faster when fish is this distance behind leader"));
				MetaData->SetValue(NewProp_hungerResetTime, TEXT("Category"), TEXT("Fish Attributes"));
				MetaData->SetValue(NewProp_hungerResetTime, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_hungerResetTime, TEXT("ToolTip"), TEXT("time after eating until it is hungry again"));
				MetaData->SetValue(NewProp_turnFrequency, TEXT("Category"), TEXT("Fish Attributes"));
				MetaData->SetValue(NewProp_turnFrequency, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_turnFrequency, TEXT("ToolTip"), TEXT("Frequency of turning ( turn every \"turnFrequency\" seconds)"));
				MetaData->SetValue(NewProp_turnSpeed, TEXT("Category"), TEXT("Fish Attributes"));
				MetaData->SetValue(NewProp_turnSpeed, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_turnSpeed, TEXT("ToolTip"), TEXT("Speed at which the fish turns (Try to have predators be slightly faster)"));
				MetaData->SetValue(NewProp_maxSpeed, TEXT("Category"), TEXT("Fish Attributes"));
				MetaData->SetValue(NewProp_maxSpeed, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_maxSpeed, TEXT("ToolTip"), TEXT("Max Speed"));
				MetaData->SetValue(NewProp_speed, TEXT("Category"), TEXT("Fish Attributes"));
				MetaData->SetValue(NewProp_speed, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_speed, TEXT("ToolTip"), TEXT("Defualt Speed"));
				MetaData->SetValue(NewProp_followDist, TEXT("Category"), TEXT("Fish Attributes"));
				MetaData->SetValue(NewProp_followDist, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_followDist, TEXT("ToolTip"), TEXT("Distance to that fish will try to remain behind leader"));
				MetaData->SetValue(NewProp_neighborType, TEXT("Category"), TEXT("Fish Attributes"));
				MetaData->SetValue(NewProp_neighborType, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_neighborType, TEXT("ToolTip"), TEXT("Neighbor type of the fish ( typically itself, but needed for code atm)"));
				MetaData->SetValue(NewProp_preyTypes, TEXT("Category"), TEXT("Fish Attributes"));
				MetaData->SetValue(NewProp_preyTypes, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_preyTypes, TEXT("ToolTip"), TEXT("Prey that the fish will attack"));
				MetaData->SetValue(NewProp_enemyTypes, TEXT("Category"), TEXT("Fish Attributes"));
				MetaData->SetValue(NewProp_enemyTypes, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_enemyTypes, TEXT("ToolTip"), TEXT("Enemies that fish will flee from"));
				MetaData->SetValue(NewProp_isLeader, TEXT("Category"), TEXT("Fish Attributes"));
				MetaData->SetValue(NewProp_isLeader, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_isLeader, TEXT("ToolTip"), TEXT("Is this fish a leader"));
				MetaData->SetValue(NewProp_FishInteractionSphere, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_FishInteractionSphere, TEXT("Category"), TEXT("Interaction"));
				MetaData->SetValue(NewProp_FishInteractionSphere, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_FishInteractionSphere, TEXT("ModuleRelativePath"), TEXT("Classes/Fish/FlockFish.h"));
				MetaData->SetValue(NewProp_FishInteractionSphere, TEXT("ToolTip"), TEXT("Fish interaction sphere"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_AFlockFish(Z_Construct_UClass_AFlockFish, &AFlockFish::StaticClass, TEXT("AFlockFish"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(AFlockFish);
	UEnum* Z_Construct_UEnum_OceanPlugin_EFollowMethod()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_OceanPlugin();
		extern uint32 Get_Z_Construct_UEnum_OceanPlugin_EFollowMethod_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("EFollowMethod"), 0, Get_Z_Construct_UEnum_OceanPlugin_EFollowMethod_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EFollowMethod"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("LookAtLocation")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("FollowCamera")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("FollowPawn")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("Stationary")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("EFollowMethod_MAX")), 4));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
			ReturnEnum->CppType = TEXT("EFollowMethod");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Classes/InfiniteSystemComponent.h"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_OceanPlugin_EFollowMethod_CRC() { return 1888713745U; }
	UClass* Z_Construct_UClass_UInfiniteSystemComponent_NoRegister()
	{
		return UInfiniteSystemComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UInfiniteSystemComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_USceneComponent();
			Z_Construct_UPackage__Script_OceanPlugin();
			OuterClass = UInfiniteSystemComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_ScaleMax = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ScaleMax"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ScaleMax, UInfiniteSystemComponent), 0x0010000000000005);
				UProperty* NewProp_ScaleMin = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ScaleMin"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ScaleMin, UInfiniteSystemComponent), 0x0010000000000005);
				UProperty* NewProp_ScaleStartDistance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ScaleStartDistance"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ScaleStartDistance, UInfiniteSystemComponent), 0x0010000000000005);
				UProperty* NewProp_ScaleDistanceFactor = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ScaleDistanceFactor"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ScaleDistanceFactor, UInfiniteSystemComponent), 0x0010000000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(ScaleByDistance, UInfiniteSystemComponent, bool);
				UProperty* NewProp_ScaleByDistance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ScaleByDistance"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ScaleByDistance, UInfiniteSystemComponent), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(ScaleByDistance, UInfiniteSystemComponent), sizeof(bool), true);
				UProperty* NewProp_MaxLookAtDistance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MaxLookAtDistance"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(MaxLookAtDistance, UInfiniteSystemComponent), 0x0010000000000005);
				UProperty* NewProp_GridSnapSize = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("GridSnapSize"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(GridSnapSize, UInfiniteSystemComponent), 0x0010000000000005);
				UProperty* NewProp_FollowMethod = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FollowMethod"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(FollowMethod, UInfiniteSystemComponent), 0x0010000000000005, Z_Construct_UEnum_OceanPlugin_EFollowMethod());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(UpdateInEditor, UInfiniteSystemComponent, bool);
				UProperty* NewProp_UpdateInEditor = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("UpdateInEditor"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(UpdateInEditor, UInfiniteSystemComponent), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(UpdateInEditor, UInfiniteSystemComponent), sizeof(bool), true);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Physics"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Object Mobility LOD PhysicsVolume"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("InfiniteSystemComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/InfiniteSystemComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Infinite Ocean Plane System.\nFollows camera and scales by distance to make a plane appear as infinite."));
				MetaData->SetValue(NewProp_ScaleMax, TEXT("Category"), TEXT("Settings"));
				MetaData->SetValue(NewProp_ScaleMax, TEXT("ModuleRelativePath"), TEXT("Classes/InfiniteSystemComponent.h"));
				MetaData->SetValue(NewProp_ScaleMin, TEXT("Category"), TEXT("Settings"));
				MetaData->SetValue(NewProp_ScaleMin, TEXT("ModuleRelativePath"), TEXT("Classes/InfiniteSystemComponent.h"));
				MetaData->SetValue(NewProp_ScaleStartDistance, TEXT("Category"), TEXT("Settings"));
				MetaData->SetValue(NewProp_ScaleStartDistance, TEXT("ModuleRelativePath"), TEXT("Classes/InfiniteSystemComponent.h"));
				MetaData->SetValue(NewProp_ScaleDistanceFactor, TEXT("Category"), TEXT("Settings"));
				MetaData->SetValue(NewProp_ScaleDistanceFactor, TEXT("ModuleRelativePath"), TEXT("Classes/InfiniteSystemComponent.h"));
				MetaData->SetValue(NewProp_ScaleByDistance, TEXT("Category"), TEXT("Settings"));
				MetaData->SetValue(NewProp_ScaleByDistance, TEXT("ModuleRelativePath"), TEXT("Classes/InfiniteSystemComponent.h"));
				MetaData->SetValue(NewProp_MaxLookAtDistance, TEXT("Category"), TEXT("Settings"));
				MetaData->SetValue(NewProp_MaxLookAtDistance, TEXT("ModuleRelativePath"), TEXT("Classes/InfiniteSystemComponent.h"));
				MetaData->SetValue(NewProp_GridSnapSize, TEXT("Category"), TEXT("Settings"));
				MetaData->SetValue(NewProp_GridSnapSize, TEXT("ModuleRelativePath"), TEXT("Classes/InfiniteSystemComponent.h"));
				MetaData->SetValue(NewProp_FollowMethod, TEXT("Category"), TEXT("Settings"));
				MetaData->SetValue(NewProp_FollowMethod, TEXT("ModuleRelativePath"), TEXT("Classes/InfiniteSystemComponent.h"));
				MetaData->SetValue(NewProp_UpdateInEditor, TEXT("Category"), TEXT("Settings"));
				MetaData->SetValue(NewProp_UpdateInEditor, TEXT("ModuleRelativePath"), TEXT("Classes/InfiniteSystemComponent.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UInfiniteSystemComponent(Z_Construct_UClass_UInfiniteSystemComponent, &UInfiniteSystemComponent::StaticClass, TEXT("UInfiniteSystemComponent"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UInfiniteSystemComponent);
	UScriptStruct* Z_Construct_UScriptStruct_FTimeDate()
	{
		UPackage* Outer = Z_Construct_UPackage__Script_OceanPlugin();
		extern uint32 Get_Z_Construct_UScriptStruct_FTimeDate_CRC();
		static UScriptStruct* ReturnStruct = FindExistingStructIfHotReloadOrDynamic(Outer, TEXT("TimeDate"), sizeof(FTimeDate), Get_Z_Construct_UScriptStruct_FTimeDate_CRC(), false);
		if (!ReturnStruct)
		{
			ReturnStruct = new(EC_InternalUseOnlyConstructor, Outer, TEXT("TimeDate"), RF_Public|RF_Transient|RF_MarkAsNative) UScriptStruct(FObjectInitializer(), NULL, new UScriptStruct::TCppStructOps<FTimeDate>, EStructFlags(0x00000001));
			UProperty* NewProp_Year = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Year"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Year, FTimeDate), 0x0010000000000005);
			UProperty* NewProp_Month = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Month"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Month, FTimeDate), 0x0010000000000005);
			UProperty* NewProp_Day = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Day"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Day, FTimeDate), 0x0010000000000005);
			UProperty* NewProp_Hour = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Hour"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Hour, FTimeDate), 0x0010000000000005);
			UProperty* NewProp_Minute = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Minute"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Minute, FTimeDate), 0x0010000000000005);
			UProperty* NewProp_Second = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Second"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Second, FTimeDate), 0x0010000000000005);
			UProperty* NewProp_Millisecond = new(EC_InternalUseOnlyConstructor, ReturnStruct, TEXT("Millisecond"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Millisecond, FTimeDate), 0x0010000000000005);
			ReturnStruct->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnStruct->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnStruct, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnStruct, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeDate.h"));
			MetaData->SetValue(NewProp_Year, TEXT("Category"), TEXT("Time"));
			MetaData->SetValue(NewProp_Year, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeDate.h"));
			MetaData->SetValue(NewProp_Year, TEXT("ToolTip"), TEXT("The year value for this time and date."));
			MetaData->SetValue(NewProp_Month, TEXT("Category"), TEXT("Time"));
			MetaData->SetValue(NewProp_Month, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeDate.h"));
			MetaData->SetValue(NewProp_Month, TEXT("ToolTip"), TEXT("The month value for this time and date."));
			MetaData->SetValue(NewProp_Day, TEXT("Category"), TEXT("Time"));
			MetaData->SetValue(NewProp_Day, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeDate.h"));
			MetaData->SetValue(NewProp_Day, TEXT("ToolTip"), TEXT("The day value for this time and date."));
			MetaData->SetValue(NewProp_Hour, TEXT("Category"), TEXT("Time"));
			MetaData->SetValue(NewProp_Hour, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeDate.h"));
			MetaData->SetValue(NewProp_Hour, TEXT("ToolTip"), TEXT("The hour value for this time and date."));
			MetaData->SetValue(NewProp_Minute, TEXT("Category"), TEXT("Time"));
			MetaData->SetValue(NewProp_Minute, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeDate.h"));
			MetaData->SetValue(NewProp_Minute, TEXT("ToolTip"), TEXT("The minute value for this time and date."));
			MetaData->SetValue(NewProp_Second, TEXT("Category"), TEXT("Time"));
			MetaData->SetValue(NewProp_Second, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeDate.h"));
			MetaData->SetValue(NewProp_Second, TEXT("ToolTip"), TEXT("The second value for this time and date."));
			MetaData->SetValue(NewProp_Millisecond, TEXT("Category"), TEXT("Time"));
			MetaData->SetValue(NewProp_Millisecond, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeDate.h"));
			MetaData->SetValue(NewProp_Millisecond, TEXT("ToolTip"), TEXT("The millisecond value for this time and date."));
#endif
		}
		return ReturnStruct;
	}
	uint32 Get_Z_Construct_UScriptStruct_FTimeDate_CRC() { return 2087800481U; }
	UFunction* Z_Construct_UFunction_ATimeManager_CalculateMoonAngle()
	{
		struct TimeManager_eventCalculateMoonAngle_Parms
		{
			FRotator ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ATimeManager();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CalculateMoonAngle"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(TimeManager_eventCalculateMoonAngle_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, TimeManager_eventCalculateMoonAngle_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FRotator());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("TimeManager"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("@Name: CalculateMoonAngle\n@Description: Calculates the moon angle rotator from the current time.\n\n@return: FRotator - The moon rotation value for the current time."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ATimeManager_CalculateMoonPhase()
	{
		struct TimeManager_eventCalculateMoonPhase_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ATimeManager();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CalculateMoonPhase"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(TimeManager_eventCalculateMoonPhase_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, TimeManager_eventCalculateMoonPhase_Parms), 0x0010000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("TimeManager"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("@Name: CalculateMoonPhase\n@Description: Calculates the moon phase for the current time and date.\n\n@return: FRotator - The moon rotation value for the current time."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ATimeManager_CalculateSunAngle()
	{
		struct TimeManager_eventCalculateSunAngle_Parms
		{
			FRotator ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ATimeManager();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CalculateSunAngle"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(TimeManager_eventCalculateSunAngle_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, TimeManager_eventCalculateSunAngle_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FRotator());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("TimeManager"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("@Name: CalculateSunAngle\n@Description: Calculates the sun angle rotator from the current time.\n\n@return: FRotator - The sun rotation value for the current time."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ATimeManager_GetDayOfYear()
	{
		struct TimeManager_eventGetDayOfYear_Parms
		{
			FTimeDate time;
			int32 ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ATimeManager();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetDayOfYear"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(TimeManager_eventGetDayOfYear_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(ReturnValue, TimeManager_eventGetDayOfYear_Parms), 0x0010000000000580);
			UProperty* NewProp_time = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("time"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(time, TimeManager_eventGetDayOfYear_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FTimeDate());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("TimeManager"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Name: GetDayOfYear\nDescription: Gets the number of full days elapsed in the current year for the provided date.\n\n@param: time (TimeDate) - The TimeDate value to calculate from.\n@return: int32 - The number of days elapsed in the current year."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ATimeManager_GetDayPhase()
	{
		struct TimeManager_eventGetDayPhase_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ATimeManager();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetDayPhase"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14020401, 65535, sizeof(TimeManager_eventGetDayPhase_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, TimeManager_eventGetDayPhase_Parms), 0x0010000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("TimeManager"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Name: GetDayPhase\nDescription: Gets the current day phase in a 0 to 1 range (fractional).\n\n@return: float - The day phase in a 0.0 to 1.0 range."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ATimeManager_GetDaysInMonth()
	{
		struct TimeManager_eventGetDaysInMonth_Parms
		{
			int32 year;
			int32 month;
			int32 ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ATimeManager();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetDaysInMonth"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(TimeManager_eventGetDaysInMonth_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(ReturnValue, TimeManager_eventGetDaysInMonth_Parms), 0x0010000000000580);
			UProperty* NewProp_month = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("month"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(month, TimeManager_eventGetDaysInMonth_Parms), 0x0010000000000080);
			UProperty* NewProp_year = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("year"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(year, TimeManager_eventGetDaysInMonth_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("TimeManager"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Name: DaysInMonth\nDescription: The number of days in the specified month (leap years are taken into account).\n\n@param: month (int32) - The month value.\n@param: year (int32) - The year value.\n@return: int32 - The number of days in the given month for the given year."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ATimeManager_GetDaysInYear()
	{
		struct TimeManager_eventGetDaysInYear_Parms
		{
			int32 year;
			int32 ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ATimeManager();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetDaysInYear"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(TimeManager_eventGetDaysInYear_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(ReturnValue, TimeManager_eventGetDaysInYear_Parms), 0x0010000000000580);
			UProperty* NewProp_year = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("year"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(year, TimeManager_eventGetDaysInYear_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("TimeManager"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Name: DaysInYear\nDescription: Gets the total number of days in a given year (takes leap years into account).\n\n@param: year (int32) - The year value.\n@return: int32 - The total number of days in the given year."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ATimeManager_GetElapsedDayInMinutes()
	{
		struct TimeManager_eventGetElapsedDayInMinutes_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ATimeManager();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetElapsedDayInMinutes"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(TimeManager_eventGetElapsedDayInMinutes_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, TimeManager_eventGetElapsedDayInMinutes_Parms), 0x0010000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("TimeManager"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Name: GetElapsedDayInMinutes\nDescription: Gets the accumulated number of minutes (plus fractional) for the current day.\n\n@return: float - The number of minutes (plus fractional minute - NOT seconds) elapsed in the given day."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ATimeManager_GetYearPhase()
	{
		struct TimeManager_eventGetYearPhase_Parms
		{
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ATimeManager();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetYearPhase"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14020401, 65535, sizeof(TimeManager_eventGetYearPhase_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, TimeManager_eventGetYearPhase_Parms), 0x0010000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("TimeManager"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Name: GetYearPhase\nDescription: Gets the current year phase in a 0 to 1 range (fractional).\n\n@return: float - The year phase in a 0.0 to 1.0 range."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ATimeManager_IncrementTime()
	{
		struct TimeManager_eventIncrementTime_Parms
		{
			float deltaSeconds;
		};
		UObject* Outer=Z_Construct_UClass_ATimeManager();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IncrementTime"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(TimeManager_eventIncrementTime_Parms));
			UProperty* NewProp_deltaSeconds = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("deltaSeconds"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(deltaSeconds, TimeManager_eventIncrementTime_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("TimeManager"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Name: IncrementTime\nDescription: Increments time based on the deltaSeconds * TimeScaleMultiplier\n\n@param: deltaSeconds (float) - The Tick (or accumulated ticks) delta time since the last update"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ATimeManager_InitializeCalendar()
	{
		struct TimeManager_eventInitializeCalendar_Parms
		{
			FTimeDate time;
		};
		UObject* Outer=Z_Construct_UClass_ATimeManager();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("InitializeCalendar"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(TimeManager_eventInitializeCalendar_Parms));
			UProperty* NewProp_time = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("time"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(time, TimeManager_eventInitializeCalendar_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FTimeDate());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("TimeManager"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Name: InitializeCalendar\nDescription: Initializes the calendar with the provided TimeDate, and validates the range of all input values.\n\n@param: time (TimeDate) - The TimeDate value to calculate from."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ATimeManager_IsLeapYear()
	{
		struct TimeManager_eventIsLeapYear_Parms
		{
			int32 year;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ATimeManager();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsLeapYear"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(TimeManager_eventIsLeapYear_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, TimeManager_eventIsLeapYear_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, TimeManager_eventIsLeapYear_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, TimeManager_eventIsLeapYear_Parms), sizeof(bool), true);
			UProperty* NewProp_year = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("year"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(year, TimeManager_eventIsLeapYear_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("TimeManager"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Name: IsLeapYear\nDescription: Determines whether the specified year is a leap year.\n\n@param: year (int32) - The year value to check\n@return: bool - Will return true if it is a leap year, otherwise false."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ATimeManager_SetCurrentLocalTime()
	{
		struct TimeManager_eventSetCurrentLocalTime_Parms
		{
			float time;
		};
		UObject* Outer=Z_Construct_UClass_ATimeManager();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetCurrentLocalTime"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(TimeManager_eventSetCurrentLocalTime_Parms));
			UProperty* NewProp_time = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("time"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(time, TimeManager_eventSetCurrentLocalTime_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("TimeManager"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Name: SetCurrentLocalTime\nDescription: Sets the local time from minutes, and runs InitializeCalendar to validate and set variables.\n\n@param: time (float) - The number of minutes (+ frac minutes) to calculate from."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_ATimeManager_NoRegister()
	{
		return ATimeManager::StaticClass();
	}
	UClass* Z_Construct_UClass_ATimeManager()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AActor();
			Z_Construct_UPackage__Script_OceanPlugin();
			OuterClass = ATimeManager::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20800080;

				OuterClass->LinkChild(Z_Construct_UFunction_ATimeManager_CalculateMoonAngle());
				OuterClass->LinkChild(Z_Construct_UFunction_ATimeManager_CalculateMoonPhase());
				OuterClass->LinkChild(Z_Construct_UFunction_ATimeManager_CalculateSunAngle());
				OuterClass->LinkChild(Z_Construct_UFunction_ATimeManager_GetDayOfYear());
				OuterClass->LinkChild(Z_Construct_UFunction_ATimeManager_GetDayPhase());
				OuterClass->LinkChild(Z_Construct_UFunction_ATimeManager_GetDaysInMonth());
				OuterClass->LinkChild(Z_Construct_UFunction_ATimeManager_GetDaysInYear());
				OuterClass->LinkChild(Z_Construct_UFunction_ATimeManager_GetElapsedDayInMinutes());
				OuterClass->LinkChild(Z_Construct_UFunction_ATimeManager_GetYearPhase());
				OuterClass->LinkChild(Z_Construct_UFunction_ATimeManager_IncrementTime());
				OuterClass->LinkChild(Z_Construct_UFunction_ATimeManager_InitializeCalendar());
				OuterClass->LinkChild(Z_Construct_UFunction_ATimeManager_IsLeapYear());
				OuterClass->LinkChild(Z_Construct_UFunction_ATimeManager_SetCurrentLocalTime());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_PartF = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PartF"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(PartF, ATimeManager), 0x0010000000000014);
				UProperty* NewProp_PartM = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PartM"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(PartM, ATimeManager), 0x0010000000000014);
				UProperty* NewProp_PartL = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PartL"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(PartL, ATimeManager), 0x0010000000000014);
				UProperty* NewProp_EcDistance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("EcDistance"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(EcDistance, ATimeManager), 0x0010000000000014);
				UProperty* NewProp_EcLatitude = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("EcLatitude"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(EcLatitude, ATimeManager), 0x0010000000000014);
				UProperty* NewProp_EcLongitude = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("EcLongitude"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(EcLongitude, ATimeManager), 0x0010000000000014);
				UProperty* NewProp_LunarElapsedDays = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LunarElapsedDays"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(LunarElapsedDays, ATimeManager), 0x0010000000000014);
				UProperty* NewProp_LunarRightAsc = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LunarRightAsc"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(LunarRightAsc, ATimeManager), 0x0010000000000014);
				UProperty* NewProp_LunarAzimuth = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LunarAzimuth"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(LunarAzimuth, ATimeManager), 0x0010000000000014);
				UProperty* NewProp_LunarDeclination = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LunarDeclination"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(LunarDeclination, ATimeManager), 0x0010000000000014);
				UProperty* NewProp_LunarHRA = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LunarHRA"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(LunarHRA, ATimeManager), 0x0010000000000014);
				UProperty* NewProp_LunarAltAngle = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LunarAltAngle"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(LunarAltAngle, ATimeManager), 0x0010000000000014);
				UProperty* NewProp_SiderealTime = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SiderealTime"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(SiderealTime, ATimeManager), 0x0010000000000014);
				UProperty* NewProp_SolarHRA = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SolarHRA"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(SolarHRA, ATimeManager), 0x0010000000000014);
				UProperty* NewProp_SolarAzimuth = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SolarAzimuth"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(SolarAzimuth, ATimeManager), 0x0010000000000014);
				UProperty* NewProp_SolarDeclination = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SolarDeclination"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(SolarDeclination, ATimeManager), 0x0010000000000014);
				UProperty* NewProp_SolarAltAngle = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SolarAltAngle"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(SolarAltAngle, ATimeManager), 0x0010000000000014);
				UProperty* NewProp_EoT = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("EoT"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(EoT, ATimeManager), 0x0010000000000014);
				UProperty* NewProp_DayOfYear = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DayOfYear"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(DayOfYear, ATimeManager), 0x0010000000000014);
				UProperty* NewProp_LSTM = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LSTM"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(LSTM, ATimeManager), 0x0010000000000014);
				UProperty* NewProp_TimeCorrection = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TimeCorrection"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(TimeCorrection, ATimeManager), 0x0010000000000014);
				UProperty* NewProp_LocalClockTime = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LocalClockTime"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(LocalClockTime, ATimeManager), 0x0010000000000014);
				UProperty* NewProp_SolarTime = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SolarTime"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(SolarTime, ATimeManager), 0x0010000000000014);
				UProperty* NewProp_TimeScaleMultiplier = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TimeScaleMultiplier"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(TimeScaleMultiplier, ATimeManager), 0x0010000000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bDaylightSavingsActive, ATimeManager, bool);
				UProperty* NewProp_bDaylightSavingsActive = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bDaylightSavingsActive"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bDaylightSavingsActive, ATimeManager), 0x0010000000000014, CPP_BOOL_PROPERTY_BITMASK(bDaylightSavingsActive, ATimeManager), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bAllowDaylightSavings, ATimeManager, bool);
				UProperty* NewProp_bAllowDaylightSavings = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bAllowDaylightSavings"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bAllowDaylightSavings, ATimeManager), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bAllowDaylightSavings, ATimeManager), sizeof(bool), true);
				UProperty* NewProp_OffsetDST = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OffsetDST"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(OffsetDST, ATimeManager), 0x0010000000000014);
				UProperty* NewProp_OffsetUTC = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OffsetUTC"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(OffsetUTC, ATimeManager), 0x0010000000000005);
				UProperty* NewProp_Longitude = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Longitude"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Longitude, ATimeManager), 0x0010000000000005);
				UProperty* NewProp_Latitude = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Latitude"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Latitude, ATimeManager), 0x0010000000000005);
				UProperty* NewProp_CurrentLocalTime = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CurrentLocalTime"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(CurrentLocalTime, ATimeManager), 0x0010000000000014, Z_Construct_UScriptStruct_FTimeDate());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ATimeManager_CalculateMoonAngle(), "CalculateMoonAngle"); // 1370798260
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ATimeManager_CalculateMoonPhase(), "CalculateMoonPhase"); // 1510554570
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ATimeManager_CalculateSunAngle(), "CalculateSunAngle"); // 562486733
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ATimeManager_GetDayOfYear(), "GetDayOfYear"); // 2335483029
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ATimeManager_GetDayPhase(), "GetDayPhase"); // 592818207
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ATimeManager_GetDaysInMonth(), "GetDaysInMonth"); // 1802385621
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ATimeManager_GetDaysInYear(), "GetDaysInYear"); // 874972641
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ATimeManager_GetElapsedDayInMinutes(), "GetElapsedDayInMinutes"); // 842927963
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ATimeManager_GetYearPhase(), "GetYearPhase"); // 2242148912
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ATimeManager_IncrementTime(), "IncrementTime"); // 2536013653
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ATimeManager_InitializeCalendar(), "InitializeCalendar"); // 148372949
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ATimeManager_IsLeapYear(), "IsLeapYear"); // 2444079423
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ATimeManager_SetCurrentLocalTime(), "SetCurrentLocalTime"); // 901425545
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("Sky/TimeManager.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("An actor based calendar system for tracking date + time, and Sun/Moon rotation/phase."));
				MetaData->SetValue(NewProp_PartF, TEXT("Category"), TEXT("Lunar Debug"));
				MetaData->SetValue(NewProp_PartF, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
				MetaData->SetValue(NewProp_PartM, TEXT("Category"), TEXT("Lunar Debug"));
				MetaData->SetValue(NewProp_PartM, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
				MetaData->SetValue(NewProp_PartL, TEXT("Category"), TEXT("Lunar Debug"));
				MetaData->SetValue(NewProp_PartL, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
				MetaData->SetValue(NewProp_EcDistance, TEXT("Category"), TEXT("Lunar Debug"));
				MetaData->SetValue(NewProp_EcDistance, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
				MetaData->SetValue(NewProp_EcLatitude, TEXT("Category"), TEXT("Lunar Debug"));
				MetaData->SetValue(NewProp_EcLatitude, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
				MetaData->SetValue(NewProp_EcLongitude, TEXT("Category"), TEXT("Lunar Debug"));
				MetaData->SetValue(NewProp_EcLongitude, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
				MetaData->SetValue(NewProp_LunarElapsedDays, TEXT("Category"), TEXT("Lunar Debug"));
				MetaData->SetValue(NewProp_LunarElapsedDays, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
				MetaData->SetValue(NewProp_LunarRightAsc, TEXT("Category"), TEXT("Lunar Debug"));
				MetaData->SetValue(NewProp_LunarRightAsc, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
				MetaData->SetValue(NewProp_LunarRightAsc, TEXT("ToolTip"), TEXT("The current Right Ascension angle for the moon"));
				MetaData->SetValue(NewProp_LunarAzimuth, TEXT("Category"), TEXT("Lunar Debug"));
				MetaData->SetValue(NewProp_LunarAzimuth, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
				MetaData->SetValue(NewProp_LunarAzimuth, TEXT("ToolTip"), TEXT("The current Azimuth angle of the moon"));
				MetaData->SetValue(NewProp_LunarDeclination, TEXT("Category"), TEXT("Lunar Debug"));
				MetaData->SetValue(NewProp_LunarDeclination, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
				MetaData->SetValue(NewProp_LunarDeclination, TEXT("ToolTip"), TEXT("The current Declination angle of the moon"));
				MetaData->SetValue(NewProp_LunarHRA, TEXT("Category"), TEXT("Lunar Debug"));
				MetaData->SetValue(NewProp_LunarHRA, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
				MetaData->SetValue(NewProp_LunarHRA, TEXT("ToolTip"), TEXT("The current Hour Angle of the moon"));
				MetaData->SetValue(NewProp_LunarAltAngle, TEXT("Category"), TEXT("Lunar Debug"));
				MetaData->SetValue(NewProp_LunarAltAngle, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
				MetaData->SetValue(NewProp_LunarAltAngle, TEXT("ToolTip"), TEXT("The current Altitude Angle of the moon"));
				MetaData->SetValue(NewProp_SiderealTime, TEXT("Category"), TEXT("Lunar Debug"));
				MetaData->SetValue(NewProp_SiderealTime, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
				MetaData->SetValue(NewProp_SiderealTime, TEXT("ToolTip"), TEXT("The current Sidereal Time value"));
				MetaData->SetValue(NewProp_SolarHRA, TEXT("Category"), TEXT("Sun Debug"));
				MetaData->SetValue(NewProp_SolarHRA, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
				MetaData->SetValue(NewProp_SolarHRA, TEXT("ToolTip"), TEXT("The current Hour Angle of the sun"));
				MetaData->SetValue(NewProp_SolarAzimuth, TEXT("Category"), TEXT("Sun Debug"));
				MetaData->SetValue(NewProp_SolarAzimuth, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
				MetaData->SetValue(NewProp_SolarAzimuth, TEXT("ToolTip"), TEXT("The Azimuth angle of the sun"));
				MetaData->SetValue(NewProp_SolarDeclination, TEXT("Category"), TEXT("Sun Debug"));
				MetaData->SetValue(NewProp_SolarDeclination, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
				MetaData->SetValue(NewProp_SolarDeclination, TEXT("ToolTip"), TEXT("The current Declination angle of the sun"));
				MetaData->SetValue(NewProp_SolarAltAngle, TEXT("Category"), TEXT("Sun Debug"));
				MetaData->SetValue(NewProp_SolarAltAngle, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
				MetaData->SetValue(NewProp_SolarAltAngle, TEXT("ToolTip"), TEXT("The current Altitude Angle of the sun"));
				MetaData->SetValue(NewProp_EoT, TEXT("Category"), TEXT("Sun Debug"));
				MetaData->SetValue(NewProp_EoT, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
				MetaData->SetValue(NewProp_EoT, TEXT("ToolTip"), TEXT("THe current Equation of Time value"));
				MetaData->SetValue(NewProp_DayOfYear, TEXT("Category"), TEXT("Sun Debug"));
				MetaData->SetValue(NewProp_DayOfYear, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
				MetaData->SetValue(NewProp_LSTM, TEXT("Category"), TEXT("Sun Debug"));
				MetaData->SetValue(NewProp_LSTM, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
				MetaData->SetValue(NewProp_LSTM, TEXT("ToolTip"), TEXT("The value of the local Standard Time Meridian (15deg intervals)"));
				MetaData->SetValue(NewProp_TimeCorrection, TEXT("Category"), TEXT("Sun Debug"));
				MetaData->SetValue(NewProp_TimeCorrection, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
				MetaData->SetValue(NewProp_TimeCorrection, TEXT("ToolTip"), TEXT("The current Time Correction factor"));
				MetaData->SetValue(NewProp_LocalClockTime, TEXT("Category"), TEXT("Sun Debug"));
				MetaData->SetValue(NewProp_LocalClockTime, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
				MetaData->SetValue(NewProp_LocalClockTime, TEXT("ToolTip"), TEXT("The current Local Clock Time value (in minutes)"));
				MetaData->SetValue(NewProp_SolarTime, TEXT("Category"), TEXT("Sun Debug"));
				MetaData->SetValue(NewProp_SolarTime, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
				MetaData->SetValue(NewProp_SolarTime, TEXT("ToolTip"), TEXT("The current Local Solar Time (in minutes)"));
				MetaData->SetValue(NewProp_TimeScaleMultiplier, TEXT("Category"), TEXT("Default"));
				MetaData->SetValue(NewProp_TimeScaleMultiplier, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
				MetaData->SetValue(NewProp_TimeScaleMultiplier, TEXT("ToolTip"), TEXT("The value to multiply the base game time by (1 second real time is multiplied to equal X seconds in game)"));
				MetaData->SetValue(NewProp_bDaylightSavingsActive, TEXT("Category"), TEXT("TimeManager"));
				MetaData->SetValue(NewProp_bDaylightSavingsActive, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
				MetaData->SetValue(NewProp_bDaylightSavingsActive, TEXT("ToolTip"), TEXT("Determines whether Daylight Savings is active for the current date"));
				MetaData->SetValue(NewProp_bAllowDaylightSavings, TEXT("Category"), TEXT("Default"));
				MetaData->SetValue(NewProp_bAllowDaylightSavings, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
				MetaData->SetValue(NewProp_bAllowDaylightSavings, TEXT("ToolTip"), TEXT("Determines whether Daylight Savings time should be enabled for the local location"));
				MetaData->SetValue(NewProp_OffsetDST, TEXT("Category"), TEXT("TimeManager"));
				MetaData->SetValue(NewProp_OffsetDST, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
				MetaData->SetValue(NewProp_OffsetDST, TEXT("ToolTip"), TEXT("The number of hours (0 or 1) to subtract for the current TimeDate for Daylight Savings Time (if enabled)"));
				MetaData->SetValue(NewProp_OffsetUTC, TEXT("Category"), TEXT("Default"));
				MetaData->SetValue(NewProp_OffsetUTC, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
				MetaData->SetValue(NewProp_OffsetUTC, TEXT("ToolTip"), TEXT("The number of hours offset from UTC for the local location (value in the range of -12 to +12 hours from UTC)"));
				MetaData->SetValue(NewProp_Longitude, TEXT("Category"), TEXT("Default"));
				MetaData->SetValue(NewProp_Longitude, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
				MetaData->SetValue(NewProp_Longitude, TEXT("ToolTip"), TEXT("The Longitude of the local location (-180 to +180 in degrees)"));
				MetaData->SetValue(NewProp_Latitude, TEXT("Category"), TEXT("Default"));
				MetaData->SetValue(NewProp_Latitude, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
				MetaData->SetValue(NewProp_Latitude, TEXT("ToolTip"), TEXT("The Latitude of the local location (-90 to +90 in degrees)"));
				MetaData->SetValue(NewProp_CurrentLocalTime, TEXT("Category"), TEXT("TimeManager"));
				MetaData->SetValue(NewProp_CurrentLocalTime, TEXT("ModuleRelativePath"), TEXT("Classes/Sky/TimeManager.h"));
				MetaData->SetValue(NewProp_CurrentLocalTime, TEXT("ToolTip"), TEXT("Current Local Clock Time (LCT)"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ATimeManager(Z_Construct_UClass_ATimeManager, &ATimeManager::StaticClass, TEXT("ATimeManager"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(ATimeManager);
	UClass* Z_Construct_UClass_UWaterHeightmapComponent_NoRegister()
	{
		return UWaterHeightmapComponent::StaticClass();
	}
	UClass* Z_Construct_UClass_UWaterHeightmapComponent()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UActorComponent();
			Z_Construct_UPackage__Script_OceanPlugin();
			OuterClass = UWaterHeightmapComponent::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B01080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_OceanManager = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("OceanManager"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(OceanManager, UWaterHeightmapComponent), 0x0040000000000000, Z_Construct_UClass_AOceanManager_NoRegister());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bDrawHeightmap, UWaterHeightmapComponent, bool);
				UProperty* NewProp_bDrawHeightmap = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bDrawHeightmap"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bDrawHeightmap, UWaterHeightmapComponent), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bDrawHeightmap, UWaterHeightmapComponent), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bDrawUsedTriangles, UWaterHeightmapComponent, bool);
				UProperty* NewProp_bDrawUsedTriangles = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bDrawUsedTriangles"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bDrawUsedTriangles, UWaterHeightmapComponent), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bDrawUsedTriangles, UWaterHeightmapComponent), sizeof(bool), true);
				UProperty* NewProp_GridSizeMultiplier = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("GridSizeMultiplier"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(GridSizeMultiplier, UWaterHeightmapComponent), 0x0010000000000005);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(bOnlyCollidingComponents, UWaterHeightmapComponent, bool);
				UProperty* NewProp_bOnlyCollidingComponents = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("bOnlyCollidingComponents"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(bOnlyCollidingComponents, UWaterHeightmapComponent), 0x0010000000000005, CPP_BOOL_PROPERTY_BITMASK(bOnlyCollidingComponents, UWaterHeightmapComponent), sizeof(bool), true);
				UProperty* NewProp_DesiredCellSize = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DesiredCellSize"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(DesiredCellSize, UWaterHeightmapComponent), 0x0010000000000005);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("BuoyantMesh/WaterHeightmapComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantMesh/WaterHeightmapComponent.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Water heightmap centered on the owning actor.\nOnly the heightmap vertices that are actually used trigger an ocean height calculation. Queries between vertices are\ninterpolated. Vertex heights are cached within a tick."));
				MetaData->SetValue(NewProp_OceanManager, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantMesh/WaterHeightmapComponent.h"));
				MetaData->SetValue(NewProp_bDrawHeightmap, TEXT("Category"), TEXT("Debug"));
				MetaData->SetValue(NewProp_bDrawHeightmap, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantMesh/WaterHeightmapComponent.h"));
				MetaData->SetValue(NewProp_bDrawUsedTriangles, TEXT("Category"), TEXT("Debug"));
				MetaData->SetValue(NewProp_bDrawUsedTriangles, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantMesh/WaterHeightmapComponent.h"));
				MetaData->SetValue(NewProp_GridSizeMultiplier, TEXT("Category"), TEXT("Water Patch"));
				MetaData->SetValue(NewProp_GridSizeMultiplier, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantMesh/WaterHeightmapComponent.h"));
				MetaData->SetValue(NewProp_GridSizeMultiplier, TEXT("ToolTip"), TEXT("How much big should the patch be, relative to the parent actor. 1 is the same."));
				MetaData->SetValue(NewProp_bOnlyCollidingComponents, TEXT("Category"), TEXT("Water Patch"));
				MetaData->SetValue(NewProp_bOnlyCollidingComponents, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantMesh/WaterHeightmapComponent.h"));
				MetaData->SetValue(NewProp_bOnlyCollidingComponents, TEXT("ToolTip"), TEXT("Only use colliding components be used to determine the water patch size?"));
				MetaData->SetValue(NewProp_DesiredCellSize, TEXT("Category"), TEXT("Water Patch"));
				MetaData->SetValue(NewProp_DesiredCellSize, TEXT("ModuleRelativePath"), TEXT("Classes/BuoyantMesh/WaterHeightmapComponent.h"));
				MetaData->SetValue(NewProp_DesiredCellSize, TEXT("ToolTip"), TEXT("Desired size for a square cell in the water patch.\nThis value might be rounded by the algorithm to make sure no cells are cut."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UWaterHeightmapComponent(Z_Construct_UClass_UWaterHeightmapComponent, &UWaterHeightmapComponent::StaticClass, TEXT("UWaterHeightmapComponent"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UWaterHeightmapComponent);
	UPackage* Z_Construct_UPackage__Script_OceanPlugin()
	{
		static UPackage* ReturnPackage = NULL;
		if (!ReturnPackage)
		{
			ReturnPackage = CastChecked<UPackage>(StaticFindObjectFast(UPackage::StaticClass(), NULL, FName(TEXT("/Script/OceanPlugin")), false, false));
			ReturnPackage->SetPackageFlags(PKG_CompiledIn | 0x00000000);
			FGuid Guid;
			Guid.A = 0x7139D1A4;
			Guid.B = 0xEE12FA36;
			Guid.C = 0x00000000;
			Guid.D = 0x00000000;
			ReturnPackage->SetGuid(Guid);

		}
		return ReturnPackage;
	}
#endif

PRAGMA_ENABLE_DEPRECATION_WARNINGS
